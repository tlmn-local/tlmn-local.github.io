[{"content":"0x00 前言 Kerberos 身份验证时不会传输用户明文密码而是使用用户明文密码派生的密钥作为加密密钥后进行身份验证，这意味着攻击者无需得到用户明文密码也可以通过认证。\nKerberos 默认支持三种加密算法：\nAES -\u0026gt; 使用 AES Key 加密 DES -\u0026gt; 使用 LM Hash 加密 RC4 -\u0026gt; 使用 NTLM Hash 加密 由于 DES 较之其它两种算法的安全性更低，默认情况下 Windows 7 和 Windows Server 2008 R2 中的 Kerberos 身份验证不再启用 DES 加密，因此本文重点关注 RC4 与 AES 下的利用。\n0x00 密钥传递 RC4 默认使用用户的 NTLM Hash 作为加密密钥，AES 默认使用用户的 AES Key 作为加密密钥，KDC 默认支持这两种加密算法，至于使用 RC4 还是 AES 则是与客户端协商后决定的（默认使用客户端支持的最高级加密算法）。\n无论使用哪种加密算法，都不会使用用户明文密码作为加密密钥，这也就意味着攻击者只需要拿到认证用户的加密密钥即可通过认证，一定程度上拿了密钥和拿明文密码已经没什么区别了。\n使用 RC4 作为加密算法进行认证的攻击手法被称为 Pass The Hash（PTH），使用 AES 作为加密算法进行认证的攻击手法被称为 Pass The Key（PTK），有时候也被称为 OverPass The Hash，两种攻击手法原理完全一致，只是加密方式与使用的加密密钥不同。\n正常的认证流程中客户端一般都支持 RC4 和 AES 两种加密算法，在协商时 KDC 会选择客户端支持的最高级加密算法（也就是 AES），因此默认情况下 Kerberos 身份验证过程中一般都是使用的 AES 加密算法。\n0x01 获取密钥 攻击者需要获取有一个认证用户的 NTLM Hash 或是 AES KEY，这一步可以通过 mimikatz 完成。\n通过 sekurlsa::logonpasswords 可以获取内存中的用户凭证，其中就包含此用户的 NTLM Hash：\n通过 sekurlsa::ekeys 可以获取用户的 AES KEY，除了 aes256 外还有 aes128，一般是用的 aes256 作为加密方式：\n0x02 获取机器 获取认证用户密钥相当于获取了此用户的 TGT，拥有了 TGT 可以干很多事情，我们可以申请任意服务的 ST，并且可以调用认证用户拥有使用权限的服务。\n由于普通的域用户一般是域内某台机器的本地管理员，本地管理员可以通过多种方式获得机器权限，但首先需要知道要控制的机器名称或是它的 IP 地址。\n实战环境中一般普通域用户只能登陆独属于他的那台机器（与实验环境不同），我们可以通过手动配置限制用户访问的机器，下面的配置表明只允许 liming 登陆 pc-02 这台机器。\n此时当 liming 尝试登陆其它机器时会遭到拒绝：\n研究后发现此配置操作的选项为活动目录中的 userWorkstations 属性，可以通过查询此属性得到用户可登陆的机器：\n➜ ldapsearch-ad git:(master) python ldapsearch-ad.py -l 192.168.216.133 -u \u0026#39;wangfei\u0026#39; -hashes \u0026#39;:e6d5638bbce5a4d5d9fd05bc712bd982\u0026#39; -t search -d corp -s \u0026#39;(samaccountname=wangfei)\u0026#39; userWorkstations ### Result of \u0026#34;search\u0026#34; command ### [+] |___userWorkstations = pc-01 NOTE：后续了解到修改 userWorkstations 只是限制的其中一种手段，还可以通过组策略去限制登陆，这块内容在后续实战中会尝试继续补全。\n0x02 修复建议 PTH 本身是设计中的正常功能，很难给出一个完美的修复方案，但是我们可以考虑从两个角度进行防御：\n预防：学习 Windows 凭证窃取方法，尝试通过计划任务定时清除本机的凭证 增加攻击成本：学习横向移动常见利用，分析流量与运行时特征，通过 HIDS 等方式进行监控报警或阻断 网上有朋友说打了 KB2871997 补丁后就无法 PTH 了，大部分文章中得出来的结论是打了补丁后 Remote UAC 策略变的更严格了，没打补丁之前只要是个本地管理员都可以 PTH（指的是利用 *exec 的功能），但打了补丁后只有 SID 为 500 的账户才能进行 PTH，同时由于域账户加入到本地管理员组后可以使用“完全管理员” 权限运行，因此同样不受 Remote UAC 的限制。\n笔者本地的环境测试后发现无论是打了补丁前还是打了补丁后本地 SID 非 500 的管理员用户都是无法 PTH 的，感觉可能是环境问题导致的，不过问题不大，我们只需要知道打了此补丁是不影响域内 PTH 的（因为域用户一般也是某台机器的本地管理员）。\n","date":"2022-10-10T00:51:57+08:00","permalink":"https://tlmn-local.github.io/2022/10/10/pass-the-hash-pass-the-key/","title":"Pass the Hash \u0026\u0026 Pass the Key"},{"content":"在学习内网渗透或实战中必然需要配置机器的 DNS 以实现访问域环境，这里提供两个在 MacOS 中配置 DNS 的方案。\n方案一：通过 WIFI GUI 进行配置，在系统偏好设置 \u0026ndash;\u0026gt; 网络 \u0026ndash;\u0026gt; 高级 \u0026ndash;\u0026gt; DNS 中可配置 DNS 服务器与检索域。\n但这样的配置与 WIFI 绑定，同时如果只配了一个 DNS 服务器容易出现当实验环境关闭时不可联网的问题。\n方案二：手动创建 /etc/resolver 目录，并以域名为名称创建文件，文件内容中包含 DNS 服务器。\n这种配置方案能够真正意义上实现对某个域名（及其子域名）使用专用的 DNS 服务器，即使 DNS 服务器关机也不影响正常上网。\n","date":"2022-10-10T00:40:48+08:00","permalink":"https://tlmn-local.github.io/2022/10/10/%E5%B0%8F%E6%8A%80%E5%B7%A7-mac-%E4%B8%8B%E7%9A%84-dns-%E9%85%8D%E7%BD%AE/","title":"小技巧 - MAC 下的 DNS 配置"},{"content":"概述 Kerberos 提供了一种在不受保护网络上验证主体（用户或网络服务器）身份的方法，这种认证方式不依赖于操作系统、主机之间的相互信任，并且假设身份认证能够在数据包沿网络传递过程中可随意读取、篡改的情况下不受影响。\n需要注意的是，作为一种身份验证服务，Kerberos 提供了一种验证网络上主体身份的方法，主要是作为授权过程中的第一步，确认客户端的身份是否正确，Kerberos 本身并不提供授权。\n为了保证认证在安全的情况下顺利进行，Kerberos 对其能够正常工作的环境有一定要求：\n不存在拒绝服务攻击（DOS） 密钥必须保密（攻击者在无密钥的情况下无法顺利通过认证） 用户的密码必须足够强大 网络上的主机间需有一个与其它主机时间的松散同步时钟，并且时钟同步必须能够保证安全 注：本文仅介绍 Kerberos 在 Microsoft Windows Domain 中的使用情况，Unix 下的使用场景不会在本文中进行介绍。\n组件 在 Kerberos 身份认证过程中有多方参与，其中包含了多个认证主体、密钥和服务，为了避免后续实际分析协议流程时被绕晕，我决定先介绍每个参与认证的组件。\n主体 与常规的认证主体不同，Kerberos 不仅包含客户端与服务端，还包含了一个受信任的第三方，完整的主体名单如下：\n客户端（想要调用某项服务的用户） 提供服务的应用服务器 KDC (Key Distribution Center)，Kerberos 的主要服务，负责签发票证，通常安装在 DC 上，其中包含 AS 服务与 TGS 服务 密钥 Kerberos 认证流程中涉及到了许多数据的加解密，其中使用到的密钥类型如下：\n用户密钥（认证用户的哈希） 服务密钥（服务所属者的哈希） 某些特殊情况下需要用到的子密钥 krbtgt 密钥（域账户 krbtgt 的哈希） 用户与服务通信时使用的服务通信密钥 用户与 KDC 通信时使用的 KDC 通信密钥 票证 Kerberos 基于票证实现完整的身份认证功能，其中主要包含两种类型的票证：\nTGT（Ticket Granting Ticket）是提交给 KDC 以请求 TGS 的票证，使用 krbtgt 密钥加密 ST （Service Ticket）是用户可用于对服务进行身份验证的票证，使用服务密钥加密 消息 Kerberos 的通信过程中使用了不同类型的消息（AS 和 TGS 有时也以 KDC 作为统称，下面的描述中对其进行了细分）：\nKRB_AS_REQ : 客户端向 AS 验证身份以获取 TGT KRB_AS_REP : AS 将 TGT 返回给客户端 KRB_TGS_REQ : 客户端使用 TGT 向 TGS 请求 ST KRB_TGS_REP : TGS 将 ST 返回给客户端 KRB_AP_REQ : 客户端使用 ST 向服务验证身份 KRB_AP_REP : 服务向客户端验证身份或返回错误信息 KRB_ERROR : 返回在 Kerberos 认证过程中的错误信息 结构 Kerberos 在通信过程中传递的消息大部分具有固定结构，此处先列出部分通信过程中使用到的结构，以便后续能够对认证流程有更为详细的认知。\nKRB_KDC_REQ 此结构是 KRB_AS_REQ 与 KRB_TGS_REQ 所使用的完整结构，两个消息共用一个结构体，并分别使用此结构体中的部分字段。\nAS-REQ ::= [APPLICATION 10] KDC-REQ TGS-REQ ::= [APPLICATION 12] KDC-REQ KDC-REQ ::= SEQUENCE { -- NOTE: first tag is [1], not [0] pvno [1] INTEGER (5) , msg-type [2] INTEGER (10 -- AS -- | 12 -- TGS --), padata [3] SEQUENCE OF PA-DATA OPTIONAL -- NOTE: not empty --, req-body [4] KDC-REQ-BODY } KDC-REQ-BODY ::= SEQUENCE { kdc-options [0] KDCOptions, cname [1] PrincipalName OPTIONAL -- Used only in AS-REQ --, realm [2] Realm -- Server\u0026#39;s realm -- Also client\u0026#39;s in AS-REQ --, sname [3] PrincipalName OPTIONAL, from [4] KerberosTime OPTIONAL, till [5] KerberosTime, rtime [6] KerberosTime OPTIONAL, nonce [7] UInt32, etype [8] SEQUENCE OF Int32 -- EncryptionType -- in preference order --, addresses [9] HostAddresses OPTIONAL, enc-authorization-data [10] EncryptedData OPTIONAL -- AuthorizationData --, additional-tickets [11] SEQUENCE OF Ticket OPTIONAL -- NOTE: not empty } KDCOptions ::= KerberosFlags -- reserved(0), -- forwardable(1), -- forwarded(2), -- proxiable(3), -- proxy(4), -- allow-postdate(5), -- postdated(6), -- unused7(7), -- renewable(8), -- unused9(9), -- unused10(10), -- opt-hardware-auth(11), -- unused12(12), -- unused13(13), -- 15 is reserved for canonicalize -- unused15(15), -- 26 was unused in 1510 -- disable-transited-check(26), -- -- renewable-ok(27), -- enc-tkt-in-skey(28), -- renew(30), -- validate(31) -- opt-hardware-auth(11), -- unused12(12), -- unused13(13), -- 15 is reserved for canonicalize -- unused15(15), -- 26 was unused in 1510 -- disable-transited-check(26), -- -- renewable-ok(27), -- enc-tkt-in-skey(28), -- renew(30), -- validate(31) pvno : 当前通信所使用的 Kerberos 版本号\nmsg-type : 当前消息类型（AS || TGS）\npadata (PreAuthentication Data) : 用于存放消息中的认证数据\nreq-body ：请求体结构\nkdc-options : 通信时设置的 Flag cname : 认证用户名称 realm : 认证客户端所处域名（在 KRB_TGS_REQ 中表示调用服务端所处域） sname : 与当前调用服务绑定的 SPN nonce : 由客户端创建的随机数，用于验证 KDC 身份，防止恶意攻击 etype : 支持的加密函数 address : 客户端主机名 enc-authorization-data : 加密的授权数据 additional-tickets : 附加票证 KRB_KDC_REP 此结构是 KRB_AS_REP 与 KRB_TGS_REP 所使用的结构体，两个消息共用一个结构体，并分别使用此结构体中的部分字段。\nAS-REP ::= [APPLICATION 11] KDC-REP TGS-REP ::= [APPLICATION 13] KDC-REP KDC-REP ::= SEQUENCE { pvno [0] INTEGER (5), msg-type [1] INTEGER (11 -- AS -- | 13 -- TGS --), padata [2] SEQUENCE OF PA-DATA OPTIONAL -- NOTE: not empty --, crealm [3] Realm, cname [4] PrincipalName, ticket [5] Ticket, enc-part [6] EncryptedData -- EncASRepPart or EncTGSRepPart, -- as appropriate } EncASRepPart ::= [APPLICATION 25] EncKDCRepPart EncTGSRepPart ::= [APPLICATION 26] EncKDCRepPart EncKDCRepPart ::= SEQUENCE { key [0] EncryptionKey, last-req [1] LastReq, nonce [2] UInt32, key-expiration [3] KerberosTime OPTIONAL, flags [4] TicketFlags, authtime [5] KerberosTime, starttime [6] KerberosTime OPTIONAL, endtime [7] KerberosTime, renew-till [8] KerberosTime OPTIONAL, srealm [9] Realm, sname [10] PrincipalName, caddr [11] HostAddresses OPTIONAL } LastReq ::= SEQUENCE OF SEQUENCE { lr-type [0] Int32, lr-value [1] KerberosTime } crealm : 认证客户端所处域名 ticket : 使用密钥加密的 Ticket 结构体 enc-part : 使用密钥加密的 EncKDCRepPart 结构体 key : 会话密钥 nonce : 客户端生成的随机数 key-expiration : 会话密钥到期时间 flags : ticket 的部分属性设置 authtime : 认证时间 starttime : 票证起始有效时间 endtime : 票证无效时间 srealm : 服务端所处域名 KRB_AP_REQ AP-REQ ::= [APPLICATION 14] SEQUENCE { pvno [0] INTEGER (5), msg-type [1] INTEGER (14), ap-options [2] APOptions, ticket [3] Ticket, authenticator [4] EncryptedData -- Authenticator } APOptions ::= KerberosFlags -- reserved(0), -- use-session-key(1), -- mutual-required(2) Authenticator ::= [APPLICATION 2] SEQUENCE { authenticator-vno [0] INTEGER (5), crealm [1] Realm, cname [2] PrincipalName, cksum [3] Checksum OPTIONAL, cusec [4] Microseconds, ctime [5] KerberosTime, subkey [6] EncryptionKey OPTIONAL, seq-number [7] UInt32 OPTIONAL, authorization-data [8] AuthorizationData OPTIONAL } authenticator : 使用密钥加密的 Authenticator 结构体 cksum : 校验和 subkey : 子密钥 KRB_AP_REP AP-REP ::= [APPLICATION 15] SEQUENCE { pvno [0] INTEGER (5), msg-type [1] INTEGER (15), enc-part [2] EncryptedData -- EncAPRepPart } EncAPRepPart ::= [APPLICATION 27] SEQUENCE { ctime [0] KerberosTime, cusec [1] Microseconds, subkey [2] EncryptionKey OPTIONAL, seq-number [3] UInt32 OPTIONAL } enc-part : 使用密钥加密的 EncAPRepPart 结构体 Ticket Ticket ::= [APPLICATION 1] SEQUENCE { tkt-vno [0] INTEGER (5), realm [1] Realm, sname [2] PrincipalName, enc-part [3] EncryptedData -- EncTicketPart } EncTicketPart ::= [APPLICATION 3] SEQUENCE { flags [0] TicketFlags, key [1] EncryptionKey, crealm [2] Realm, cname [3] PrincipalName, transited [4] TransitedEncoding, authtime [5] KerberosTime, starttime [6] KerberosTime OPTIONAL, endtime [7] KerberosTime, renew-till [8] KerberosTime OPTIONAL, caddr [9] HostAddresses OPTIONAL, authorization-data [10] AuthorizationData OPTIONAL } TransitedEncoding ::= SEQUENCE { tr-type [0] Int32 -- must be registered --, contents [1] OCTET STRING } TicketFlags ::= KerberosFlags -- reserved(0), -- forwardable(1), -- forwarded(2), -- proxiable(3), -- proxy(4), -- may-postdate(5), -- postdated(6), -- invalid(7), -- renewable(8), -- initial(9), -- pre-authent(10), -- hw-authent(11), -- the following are new since 1510 -- transited-policy-checked(12), -- ok-as-delegate(13) enc-part : 使用密钥加密的 EncTicketPart 结构体 key : 会话密钥 crealm : 票证作用域名 cname : 票证所属用户名 authorization-data : 插入在票证中的授权数据，微软的实现中插入的是由密钥加密的认证用户特权证书 AuthorizationData AuthorizationData ::= SEQUENCE OF SEQUENCE { ad-type [0] Int32, ad-data [1] OCTET STRING } ad-type : 授权类型 ad-data : 授权数据 特权证书 特权证书（PAC）是微软对 Kerberos 进行扩展后实现的，其包含用户的权限，并使用 krbtgt 密钥进行签名，最终被包含在 KDC 颁发的票证中，服务可以通过与 KDC 通信对 PAC 进行验证，但此处只会检查 PAC 是否被篡改，而不会检查其中包含的权限是否正确。\n注：用户可在 KRB_AS_REQ 的 padata 中设置 Flag 表明不需要在 Ticket 中包含 PAC 。\n认证流程 本章将通过模拟 Kerberos 认证场景来分析 Kerberos 认证细节，强烈建议看完 0x01 中组件的分析再来看这一部分，能够更加直观的了解认证细节。\n某次完整的 Kerberos 认证所发出的消息如下：\n其中 192.168.10.36 作为客户端向 192.168.10.35 请求 SMB 服务调用，192.168.10.34 为 DC 所属 IP。\nKRB_AS_REQ 此消息用于向 AS 服务验证身份并请求 TGT ，有两种验证模式，区别为是否使用了预认证模式。为了实现兼容，Kerberos 5 中默认会先发送一个不带预认证数据的 KRB_AS_REQ ，如果认证用户不支持这种认证模式则 KDC 会通过 KRB_ERROR 消息返回具体错误，此时客户端会将预认证数据加入到 KRB_AS_REQ 中再次发送请求。\n由于使用预认证数据的是较为通用的场景，因此本节着重分析实验了预认证数据的认证模式，另外一种不使用预认证数据的认证模式留待后续 Kerberos 安全隐患章节中再进行分析。\n在使用了预认证数据的场景中，客户端首先会使用用户密钥加密一个时间戳并将其加入到 padata 字段中，与其一同加入到还有 pA-PAC-REQUEST 这个属性，前者为了向 KDC 验证身份，后者则是设置是否需要在 Ticket 中包含 PAC。\nKRB_AS_REP AS 服务收到 KRB_AS_REQ 请求后，首先在活动目录中查找认证用户对应到哈希并使用其作为密钥解密 padata 中的 pA-ENC-TIMESTAMP，如果解密失败则代表认证失败；解密成功后获得一个时间戳，接着用本地时间与时间戳相减得到一个差值，如果此差值在允许范围内则认证成功。\n认证成功后将会生成两个重要的结构体，一个是 TGT ，另一个则是 EncKDCRepPart ，前者使用 krbtgt 密钥加密，后者使用用户密钥加密，两个结构体均包含一个相同的 KDC 会话密钥；如果在 KRB_AS_REQ 中 pA-PAC-REQUEST 设为 true ，还会将用户的 PAC 放置在 TGT 中。\nKRB_TGS_REQ 客户端收到 KRB_AS_REP 后，首先使用用户密钥解密 EncKDCRepPart 获得 KDC 会话密钥，并判断 EncKDCRepPart 中的 nonce 是否与 KRB_AS_REQ 中的一致；随后创建一个 AP-REQ 结构体，使用 KDC 会话密钥加密其中的 Authenticator，最后将与调用服务向绑定的 SPN 封装入 req-body 的 sname 中，并封装为 KRB_TGS_REQ 消息发送给 TGS 服务以换取 ST。\n其中的 nonce 作用与前文一致，用于在 ST 的申请过程中校验 TGS 服务的身份（如果 TGS 服务是伪造的，那么它无法加密对应的 EncKDCRepPart，因为其没有用户密钥）；可以注意到此处还包含一个奇怪的 enc-authorizatfion-data ，不必惊讶，这是一个额外字段，某些应用程序在认证时需要用到此字段，其由 authenticator 中的 subkey 进行加密。\nKRB_TGS_REP 当 TGS 服务收到 KRB_TGS_REQ 后，首先使用 krbtgt 密钥解密 TGT 从而获得先前协商的 KDC 会话密钥，随后使用 KDC 会话密钥解密 authenticator 字段，并利用其中的 subkey 解密 enc-authorizatfion-data 。\n如果三者都能解密成功，则会进行一系列的校验，包括 TGT 是否过期，数据包是否被篡改等等；校验通过后 TGS 会提取出 req-body 中的 sname，并在活动目录中寻找服务账户对应的哈希，以此为密钥加密 ST，如果 TGT 中存在 PAC，则将 PAC 同样放置到 ST 中，同时还将使用 KDC 会话密钥生成 EncKDCRepPart 结构体，其中包含了后续调用服务时需要用上的服务会话密钥（ST 中同样包含）。\nKRB_AP_REQ 当客户端收到 KRB_TGS_REP 后，首先使用 KDC 会话密钥解密 EncTGSRepPart ，校验其中的 nonce 是否与客户端设置的 nonce 一致；校验成功后从 EncTGSRepPart 中提取出服务会话密钥，使用服务会话密钥加密 Authenticator 以此向服务端验证身份，并将 ST 与 Authenticator 一同发送给服务端。\nKRB_AP_REP（可选） 服务端收到 KRB_AP_REQ 后，首先使用其服务密钥解密 ST ，从中提取出服务会话密钥，并尝试使用服务会话密钥解密 Authenticator ，如果解密成功则代表客户端的身份验证成功，此时则根据 ST 中的 PAC 对用户权限进行判断，如其拥有足够的权限则向其提供服务。\nKRB_AP_REP 是可选的，多用于传递错误信息或由服务端向客户端验证身份（nonce）：\n总结 上面一串流程下来也许会觉得很绕，毕竟其中使用了大量的临时会话密钥与加密密钥，同时还用上了许多不同的结构体，接下来简单梳理一下每个密钥都是在哪生成、在哪使用的。\nKRB_AS_REQ 使用了用户密钥 KRB_AS_REP 使用了用户密钥 使用了 krbtgt 密钥 生成了 KDC 会话密钥 KRB_TGS_REQ 使用了用户密钥 使用了 KDC 会话密钥 KRB_TGS_REP 使用了 KDC 会话密钥 生成了服务会话密钥 使用了 krbtgt 密钥 使用了服务密钥 KRB_AP_REQ 使用了 KDC 会话密钥 使用了服务会话密钥 KRB_AP_REP 使用了服务会话密钥 仔细看完后感觉 Kerberos 之所以复杂并不仅仅在于其加密流程，而在于其每一次通信都存在着大量的加解密、两端身份的相互验证、消息的保密性，同时还需要确保 TGT 和 ST 的安全性、完整性等，只能说设计这个协议的团队真的太 🐮🍺 辣！\n","date":"2022-03-24T17:59:34+08:00","permalink":"https://tlmn-local.github.io/2022/03/24/kerberos-protocol/","title":"Kerberos Protocol"},{"content":"概述 NTLM 是 Windows 众多认证协议之一，早期曾是 Windows 主要的认证方式，即使在后来 Kerberos 取代了 NTLM 作为首选的身份认证协议，但还是有很多场景必然需要使用到 NTLM 进行身份认证，包括但不限于：\n其中一方不支持 Kerberos 其中一方未加入域中（工作组环境） 应用程序选择使用 NTLM 作为认证协议（如部分 HTTP、SMB、SMTP、MSSQL\u0026hellip;） 可以发现 NTLM 在现在也有着大量的使用场景，因此研究它的原理、脆弱性及修复方式也是很有必要的，无论你是作为攻击者或是防守方。\nNTLM 是一种基于挑战/响应的身份认证协议，这里需要注意一点，NTLM 是作为第三方模块单独嵌入到应用程序中使用的，应用程序使用 NTLM 进行身份认证，并将会话层与认证层相互隔离，认证细节对应用程序是透明的，这种认证方式是一把双刃剑，后文中会谈到。\n下图是客户端与服务端在通信过程中使用 NTLM 进行认证的一般流程，可以发现 NTLM Message 是嵌入到应用程序正常的 Message 中的：\nNTLM 有着悠久的发展历史，作为 Windows 最早的认证协议之一，其有着多个历史版本，包括 LM、NTLMv1 和 NTLMv2，几个版本的认证流程基本相同，区别仅在于计算 Response 的方式与设置了哪些 Response 字段。\n两种模式 NTLM 对于连接是否保持（TCP、UDP）设计了两种认证模式，一种是面向连接的，另一种则是无连接的，前者是目前用的最多的模式（因为大部分使用 NTLM 作为认证协议的应用均采用 TCP 进行数据传输）。\n面向连接的认证流程如下：\n首先是客户端与服务端会进行正常通信，随后客户端发起 NEGOTIATE 消息告知服务端开始认证，服务端发送 CHALLENGE 消息告知客户端 Challenge，客户端计算后得到 Response 并发送 AUTHENTICATE 消息进行认证，注意最后一条 Application message 不代表服务端不告知客户端认证结果，而是因为认证结果以何种形式发送是由应用程序决定的，此时已经与 NTLM 无关了。\n无连接的认证流程如下：\n从上述认证流程上看，虽然是服务端先向客户端发送了 Challenge，但实际上是由客户端通过应用程序自定义的某种消息先启动了认证流程，从整体上看与面向连接的认证方式基本一致，只不过第一步转为了应用程序自定义的消息。\n上面说了 NTLM 存在多个版本，其中 LM 已经基本废弃，较为常用的是 NTLMv1 与 NTLMv2 两个版本，至于使用哪个版本进行认证，则需要客户端与服务端共同设置，通常这里不会进行协商，而是直接在应用程序中写成固定代码。\nHash Windows 中不会存储用户密码的明文，只会存储其 Hash（后文称为哈希），本地用户的密码哈希存放于当前机器的 SAM 文件中，域用户的密码哈希则存放于域控制器（Domain Controller）的 NTDS.DIT 文件中，默认情况下这两个文件是不可访问的，但可利用其它方式将哈希导出。\n用户哈希通常由 LM-Hash 与 NT-Hash 两部分组成，其中 LM-Hash 是 Windows 最早使用的加密算法，核心使用了 DES 算法进行加密，由于 LM-Hash 存在较多的安全风险，于是从 Windows Vista 和 Windows Server 2008 开始，Windows 默认禁用了 LM-Hash，只启用 NT-Hash（有的文中也将其称为 NTLM-Hash 或是 NTLM，为了避免与协议名称混淆，这里记为 NT-Hash），因此在大多数操作系统中我们获取到的哈希可能是这样的：\n{Username}:{SID}:AAD3B435B51404EEAAD3B435B51404EE:62f83cc8d728c97df1e3b0a94e5c3ef9 其中 AAD3B435B51404EEAAD3B435B51404EE 为 LM-Hash，62f83cc8d728c97df1e3b0a94e5c3ef9 为 NT-Hash，如果某用户没有设置密码或当前的操作系统设置为不存储 LM-Hash，那么所获取到的 LM-Hash 就是 AAD3B435B51404EEAAD3B435B51404EE ，可以理解为空值，此哈希并没有价值，但某些工具要求输入格式为 {LM-Hash}:{NT-Hash} ，此时可将其设置为 0 值：00000000000000000000000000000000:{NT-Hash} 即可。\n备注：\nSAM Path：C:\\Windows\\System32\\config\\SAM NTDS.DIT Path：%SystemRoot%\\NTDS\\ntds.dit LM-Hash 加密算法 LM Hash 的加密算法如下：\n将所有字符转换为大写并转换为十六进制 如果长度不足14字节则在右侧填充 NULL 补充 将字符串分割为两个7字节的 chunk 将两个 chunk 分别先转为十六进制再转二进制 如果 chunk 的长度不到56则将其分割为7位一组并在每组末尾加0（最后一组除外） 将结果转为二进制后再转十六进制 去除开头的 0x 部分 以及右侧 L 字符后再次将两个 chunk 分别转为十六进制 将两个 chunk 分别作为 key 通过 DES 加密 KGS!@#$% 字符串 将加密结果合并，得到最终的 LM-Hash 转换为 Python 代码如下（Python3）：\nimport binascii from pyDes import * def encode_des(data, key): key = des(key, ECB, pad=None) encrypt_data = key.encrypt(data) return binascii.b2a_hex(encrypt_data) def padding_zero(data): result = [] length = len(data) for i in range(length): if i % 7 == 0: result.append(data[i:i + 7] + \u0026#39;0\u0026#39;) return \u0026#39;\u0026#39;.join(result) def get_lm_hash(password): password = password.upper() # 转换为大写 hex_password = str(binascii.b2a_hex(password.encode(\u0026#39;utf-8\u0026#39;)), encoding=\u0026#39;utf-8\u0026#39;) # 转换为十六进制字符串 hex_password = hex_password.ljust(28, \u0026#39;0\u0026#39;) # 不足十四字节的部分用0补全 # 将十六进制字符串分为两个部分，每部分有七个字节 hex_password_part_one = hex_password[0:14] hex_password_part_two = hex_password[14:28] # 将这两部分分别先转为十六进制再转为二进制 hex_password_part_one = bin(int(hex_password_part_one, 16)) hex_password_part_two = bin(int(hex_password_part_two, 16)) # 将这两部分分别用0左填充长度至56 hex_password_part_one = hex_password_part_one.lstrip(\u0026#39;0b\u0026#39;).rjust(56, \u0026#39;0\u0026#39;) hex_password_part_two = hex_password_part_two.lstrip(\u0026#39;0b\u0026#39;).rjust(56, \u0026#39;0\u0026#39;) # 将两部分分别以7位一组，每组末尾加0（除最后一组） padding_part_one = padding_zero(hex_password_part_one) padding_part_two = padding_zero(hex_password_part_two) # 将结果转换为二进制后再转为十六进制 padding_part_one = hex(int(padding_part_one, 2)) padding_part_two = hex(int(padding_part_two, 2)) # 去除开头的0x部分以及右侧的L字符 padding_part_one = padding_part_one[2:].rstrip(\u0026#39;L\u0026#39;) padding_part_two = padding_part_two[2:].rstrip(\u0026#39;L\u0026#39;) # 如果part_2为0x0，则将其转换为0000000000000000进行适配 if padding_part_two == \u0026#39;0\u0026#39;: padding_part_two = \u0026#39;0000000000000000\u0026#39; # 将其转换为十六进制 padding_part_one = binascii.a2b_hex(padding_part_one) padding_part_two = binascii.a2b_hex(padding_part_two) # 将每个部分作为key加密KGS!@#$%字符串 lm_part_one = encode_des(\u0026#34;KGS!@#$%\u0026#34;, padding_part_one) lm_part_two = encode_des(\u0026#34;KGS!@#$%\u0026#34;, padding_part_two) # 两组des加密结果拼接在一起，就是最终的结果 final_lm_hash = str(lm_part_one + lm_part_two, encoding=\u0026#39;utf-8\u0026#39;) return final_lm_hash if __name__ == \u0026#39;__main__\u0026#39;: print(get_lm_hash(\u0026#39;\u0026lt;password\u0026gt;\u0026#39;)) 从代码上看，LM-Hash 存在许多脆弱的设计，如：\n不区分大小写 密码长度不能超过14位 使用分组拼接的方式计算 Hash，在得到 Hash 后也可使用分组爆破的方式还原密码，并且如果密码小于7位则后半段加密字符串必然是 aad3b435b51404ee NT-Hash 加密算法 NT Hash 的加密算法的计算步骤较之LM Hash则简单许多：MD4(UTF-16-LE(password))，转换为Python代码如下：\nimport hashlib import binascii password = \u0026#39;\u0026lt;password\u0026gt;\u0026#39; print(str(binascii.hexlify(hashlib.new(\u0026#39;md4\u0026#39;,password.encode(\u0026#39;utf-16le\u0026#39;)).digest()),encoding=\u0026#39;utf-8\u0026#39;)) 验证 对测试密码 DC082!@# 进行加密计算 LM-Hash 与 NT-Hash，所得结果与图中一致：\n$ python3 lm_hash.py a0ecede8e75ed1b4c2a20cae7226e17d $ python3 nt_hash.py cdf300d7f4c17e59e3b96a05794aa007 NTLM 微软最早使用的认证协议是使用 LM-Hash 作为密钥的 LM，在上面曾提及 LM-Hash 存在诸多安全隐患，因此微软于1993年 Windows NT 3.1 中引入了 NTLMv1，并加入了 NT-Hash，此时 LM-Hash 与 NT-Hash 将共同使用，同时为了一定程度缓解重放攻击，微软在 Windows NT 4.0.SP4 中引入了 NTLMv2；本文将结合 SMB 的调用流程来对 NTLM 的认证过程进行实际分析（这里不区分v1或是v2，两个版本认证流程一致）。\n使用命令 net use \\\\192.168.2.110 \u0026quot;Admin!@#$~!@#01\u0026quot; /user:\u0026quot;Administrator\u0026quot; 尝试通过 SMB 协议链接 192.168.2.110 的共享资源，其中与 NTLM 认证有关的是图中圈起来的四条消息：\n首先客户端发送 NEGOTIATE 消息启动认证流程，此消息会对本次认证中使用的安全机制进行协商(flag)，并将客户端的域名和工作组名一同传递给服务端：\n随后服务端饭后 CHALLENGE 消息和 MORE_PROCESSING_REQUIRED 状态码告知客户端还需要传递用户信息以进行接下来的认证，CHALLENGE 中包含诸多来自服务端的信息，包括最重要的 Challenge、Timestamp（用于缓解重放攻击）和服务端机器的相关信息（机器名、域名、DNS 域名及 DNS 机器名：\n当客户端收到这一条消息后，会从中提取出 challenge，并使用用户提供的密码生成对应的 NT-Hash 以及 LM-Hash，并使用对应的 Hash 对 challenge 和其余信息合并后进行加密，最终得到一个加密串，具体处理代码如下（伪代码）。\nNTLMv1：\n-- -- Functions Used: -- Z(M)- Defined in section 6. Define NTOWFv1(Passwd, User, UserDom) as MD4(UNICODE(Passwd)) EndDefine Define LMOWFv1(Passwd, User, UserDom) as ConcatenationOf( DES( UpperCase( Passwd)[0..6],\u0026#34;KGS!@#$%\u0026#34;), DES( UpperCase( Passwd)[7..13],\u0026#34;KGS!@#$%\u0026#34;)) EndDefine Set ResponseKeyNT to NTOWFv1(Passwd, User, UserDom) Set ResponseKeyLM to LMOWFv1( Passwd, User, UserDom ) Define ComputeResponse(NegFlg, ResponseKeyNT, ResponseKeyLM, CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge, Time, ServerName) As If (User is set to \u0026#34;\u0026#34; AND Passwd is set to \u0026#34;\u0026#34;) -- Special case for anonymous authentication Set NtChallengeResponseLen to 0 Set NtChallengeResponseMaxLen to 0 Set NtChallengeResponseBufferOffset to 0 Set LmChallengeResponse to Z(1) ElseIf If (NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY flag is set in NegFlg) Set NtChallengeResponse to DESL(ResponseKeyNT, MD5(ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge))[0..7]) Set LmChallengeResponse to ConcatenationOf{ClientChallenge, Z(16)} Else Set NtChallengeResponse to DESL(ResponseKeyNT, CHALLENGE_MESSAGE.ServerChallenge) If (NoLMResponseNTLMv1 is TRUE) Set LmChallengeResponse to NtChallengeResponse Else Set LmChallengeResponse to DESL(ResponseKeyLM, CHALLENGE_MESSAGE.ServerChallenge) EndIf EndIf EndIf Set SessionBaseKey to MD4(NTOWF) NTLMv2：\nDefine NTOWFv2(Passwd, User, UserDom) as HMAC_MD5( MD4(UNICODE(Passwd)), UNICODE(ConcatenationOf( Uppercase(User), UserDom ) ) ) EndDefine Define LMOWFv2(Passwd, User, UserDom) as NTOWFv2(Passwd, User, UserDom) EndDefine Set ResponseKeyNT to NTOWFv2(Passwd, User, UserDom) Set ResponseKeyLM to LMOWFv2(Passwd, User, UserDom) Define ComputeResponse(NegFlg, ResponseKeyNT, ResponseKeyLM, CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge, Time, ServerName) As If (User is set to \u0026#34;\u0026#34; \u0026amp;\u0026amp; Passwd is set to \u0026#34;\u0026#34;) -- Special case for anonymous authentication Set NtChallengeResponseLen to 0 Set NtChallengeResponseMaxLen to 0 Set NtChallengeResponseBufferOffset to 0 Set LmChallengeResponse to Z(1) Else Set temp to ConcatenationOf(Responserversion, HiResponserversion, Z(6), Time, ClientChallenge, Z(4), ServerName, Z(4)) Set NTProofStr to HMAC_MD5(ResponseKeyNT, ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge,temp)) Set NtChallengeResponse to ConcatenationOf(NTProofStr, temp) Set LmChallengeResponse to ConcatenationOf(HMAC_MD5(ResponseKeyLM, ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge)), ClientChallenge ) EndIf Set SessionBaseKey to HMAC_MD5(ResponseKeyNT, NTProofStr) EndDefine 对比一下两者的加密算法，可以发现 NTLMv1 的加密较为简单，NTLMv2 的加密中除了 challenge 外还会将大量信息通过连接起来最后才进行加密，同时使用了 HMAC_MD5 进行以保护数据的完整性。\n可以发现 NTLMv1 是不存在 NTProofStr 这个数据的，因此也可以通过是否存在 NTProofStr 来判断当前认证使用的是哪个版本，下面是 SMB2 中使用 NTLMv2 进行认证的 AUTHENTICATE 消息：\n这里的 NTLMv2 Response 中的每一个字段都是受到 NTProofStr 保护的，因为 NTProofStr 是根据这些字段值和 challenge 生成出来的，因此新增或是修改其中任何一个字段都会导致服务端最后校验 NTProofStr 不成功，因为攻击者无法在没有 Hash 的情况 下重新生成 NTProofStr，这点很重要，也算是 NTLMv2 的一种保护机制。\n当服务端收到客户端的 Response 后，可根据服务端环境分为两种不同的处理方式：\n在域环境中，服务端将 Challenge、Response Username 等信息发送给 DC，由 DC 调用 NTOWFv2 、LMOWFv2 对存储于 DC 上的域成员哈希计算对应的 NTProofStr 和 LM-Response，如果与客户端传递过来的相同则认证通过，反之则不通过 在工作组环境中，服务端调用 NTOWFv2 、LMOWFv2 对存储于服务端机器上的用户哈希计算对应的 NTProofStr 和 LM-Response，如果与客户端传递过来的相同则认为认证通过，反之则不通过 NTLM Relay NTLM 有着许多的攻击面，包括诸如哈希传递（PTH）、哈希爆破等，但这些都是与哈希有关的，本文只记录与协议有关的一种攻击手法，即 NTLM Relay。\n从 NTLM 的认证流程可以看出，服务端会对客户端的身份进行认证，然而客户端并不会对服务端的身份进行认证（即单向认证），也正是因为这种单向认证，才产生了 NTLM Relay 这种中间人攻击的手法。\n正常的认证流程是向下图这样的：\n假设攻击者有能力作为中间人的身份存在于客户端与服务端之间（也就是能够让客户端主动向攻击者发起 NTLM 认证请求），此时攻击者只需要简单的转发数据包，即可以客户端的身份调用服务端所提供的服务：\n以服务器的角度看，它已经完成了对客户端的身份验证，并且完全无法意识到此时的通信中存在着中间人，当身份认证完成后，攻击者可使用服务端下发的认证凭据以客户端的身份调用其对外提供的服务。\n如果根据 Relay 的对象来区分，可以得出一个结论：工作组环境通常是 Relay 回自身以获得主机权限，域环境较之工作组环境扩充了许多玩法，此时则不仅局限于 Relay 自身，通常还可 Relay 至 DC 以实现其它操作。\n现假设存在 A、B、C 三台主机，假设 A 和 C 上存在着某个用户名和密码均相同的用户（如 Administrator），攻击者获取到了 B 的权限并且通过某种方式可以让 A 主动发起 SMB 请求，那么攻击者可以在 B 上架设一个恶意的中转 SMB 服务器，此时 B 上获得 A 的 NTLM 认证请求并将其转发至 C 的 SMB 服务（无跨协议），从而获得 C 的主机权限，impacket 的 ntlmrelayx.py 已经很好的集成了 ntlm relay 的大部分玩法：\n上面是我通过 impacket 启动了一个恶意的 SMB 服务，并将认证请求转发给 192.168.2.112（C） 这台主机，成功认证后会在本地创建一个代理，后序我可通过此代理调用目标的 SMB 服务，比如通过 smbexec.py 实现命令执行：\n看流量图也许能够更好的理解 NTLM Relay：\n在上图中，A 主机（192.168.2.113）向 B 主机（192.168.2.109）发出的消息会被修改（修改部分 Client 信息）后转发到 C 主机（192.168.2.112），随后将 C 主机的响应修改部分信息后转发给 B 主机。\n上面多次提到了跨协议，为什么 NTLM Relay 能够跨协议呢？这是因为 NTLM 是一个嵌入式协议，无论对于哪个上层应用来说它的认证方式是不变的，不会受到上层应用的影响，因此当攻击者收到一个 SMB 的 NTLM 认证后，可转发给其它机器的 LDAP 或是其它服务进行认证。\n防御措施 上面介绍了 NTLM Relay 的攻击原理与攻击场景，接下来将主要分析微软对于 NTLM Relay 的多种防御措施，其中有几种防御措施相辅相成，相互关联，十分精彩！\nms08-068 NTLM Relay 不仅可以 Relay 到其它机器，在工作组环境下也可以 Relay 到发出请求的机器已获得其主机权限，如下图所示：\n微软在2008年发布了 ms08-068 补丁用于缓解这种 Relay To Self 的场景，它是怎么工作的呢？根据文档描述，SMB 客户端在进行认证时需要循环调用 InitializeSecurityContext直到其返回 SEC_E_OK 才表示认证成功，ms08-068 的修复方式是将调用函数过程中传递的 pszTargetName 由原先的 null 修改为服务端具体服务的SPN，即当我们想访问 \\\\smb-server\\share 时，此处会被设置为 cifs/smb-server 。\n接下来要介绍一下 challenge cache 机制，它是能够防御 Relay To Self 的核心原因，当然需要搭配 pszTargetName 进行使用，下面是被防御的场景，假设 A 是受害者的机器，B 是 攻击者的机器，攻击者通过某种方式让 A 向其发起了 SMB 请求，并希望 Relay To A：\nA --\u0026gt; B --\u0026gt; A-SMB （NEGOTIATE） A-SMB --\u0026gt; B --\u0026gt; A （CHALLENGE），此处当 A 收到 challenge 后，会将 challenge 与 B 的 SPN 一同缓存 A --\u0026gt; B --\u0026gt; A-SMB （Response），当 A 的 SMB 服务收到 Response后，会判断 challenge 是否在本地存在，如果存在并且 SPN 不为本机， 则认为此次 Response 为 NTLM Relay 转发过来的，因此认证失败 CVE-2019-1384（Ghost Potato） CVE-2019-1384 则是用于绕过 ms08-068 的攻击手法，由于缓存至多存在300s，过了300s缓存就会自动被删除，因此只需要将 SMB 的请求一直保持，等待300s后再发送 Response 即可成功绕过 ms08-068 的防御。\n微软在 2019年12月11日 发布了修复此漏洞的补丁：CVE-2019-1384 。\n会话签名 正如之前说的一样，NTLM 只是身份认证层的实现，当身份认证完毕后，应用层协议会继续使用它们的协议规范进行服务的调用，后续服务调用的过程被称为会话层，会话签名是基于用户 Hash 生成的，因此攻击者无法伪造。\n当认证完毕后，如果存在客户端与服务的协商的决定是要对后续所有会话进行签名，那么攻击者将无法利用 Relay ，因为攻击者无法修改会话时所调用服务的 Action 或是 Relay 去其它协议，下图是基于会话签名保护的服务调用流程：\n下图是基于会话签名保护的 NTLM Relay 流程：\n由于后续攻击者必然想调用自定义的 Action（如 smbexec），但由于攻击者没有办法生成会话签名，因此服务端对签名的校验失败，将拒绝提供服务。\nSMB Signing SMB 协议的会话签名是在 SMB 协议中实现的，不涉及 NTLM，是否需要进行签名实际上是客户端与服务端在 NTLM 认证前就已经协商好了的，首先客户端会向服务端发送一条 NEGOTIATE 消息以告知服务端其对签名的处理方式（注意此处的 NEGOTIATE 与 NTLM 无关，是 SMB 协议自己的 NEGOTIATE）：\n随后服务端会在 NEGOTIATE Response 中告知其对签名的处理方式：\n可以发现此时客户端与服务端的处理方式都是 enable，那么它们到底是签名还是不签名呢？微软官方提供了一个矩阵用于确定 客户端、服务端、NTLM 版本为何值时需要进行签名，并且其中包含一系列额外条件，如域控制器是强制签名的之类。\n通过上面的矩阵可以得出本次是否签名的结论，由于此次使用的是 SMBv2 协议，并且对话的双方均不是域控制器，因此后续会话将不进行签名验证。\n当客户端向域控制器验证身份时是需要签名的，但当域控制器向另外一台域控制器验证身份时则是不需要签名的。\n总结一下整个流程：\n对应的上层协议在 NEGOTIATE 消息中告知对方其对签名的处理方式 Client 在 NTLM NEGOTIATE 消息中告知 Server 其是否支持签名，Server 在 NTLM Challenge 中告知 Client 其是否支持签名 Client 认证完毕，发起后续会话，如果前面一系列的协商结果为需要签名，则 Client 会在后续流量中添加一个 Signature 字段用于签名，Server 与 Client 的处理方式一致 LDAP Signing 在调用 LDAP 服务时，客户端与服务端同样有着 3 个选项来协商是否需要进行签名：\nDisabled：不支持数据包签名 Negotiated：可以处理签名，但不要求一定要签名 Required：必须对数据包进行签名 LDAP 是在 NTLM 认证时进行签名协商的，首先在 NTLM NEGOTIATE 消息中，客户端会设置 Flag 表示其能够处理签名：\n随后服务端会在 CHALLENGE 消息中设置 Flag 以告知其是否能够处理签名：\n由于默认情况下除了域控外的所有主机最终的协商均为 Negotiated（两台服务器均能够处理签名），这也表示正常情况下认证完毕后的所有 LDAP 流量均受签名的保护。\n可以发现 SMB 与 LDAP 的区别，SMB 的签名协商是发生在 SMB 协议上的，而 LDAP 的签名协商则是发生在 NTLM 认证时的，那是否意味着只要攻击者将 Negotiate Sign 设置为 False 即可绕过签名？可惜的是，NTLM 也有自己的消息完整性验证机制，即后文要介绍的 MIC。\nMIC MIC（Message Integrity Code）的主要目的是为了保证数据的完整性，即从客户端发出去是什么数据就应该在服务端收到什么数据，它只包含在 NTLM 认证流程中的最后一条消息（AUTHENTICATE）中被发出，算法如下：\nHMAC_MD5(Session key, NEGOTIATE_MESSAGE + CHALLENGE_MESSAGE + AUTHENTICATE_MESSAGE) 由于 Session Key 是由用户的 Hash 所加密得到的，这也就意味着攻击者没有办法重新计算 MIC，而 MIC 中包含了三条消息，这也意味着攻击者没有办法修改前两条消息，因为这将导致服务端算出来的 MIC 无法正确校验。\n由于 MIC 是可选的，因此在转发数据包的过程中可以将 MIC 删除，但这是无效的，因为在 AUTHENTICATE 消息中还存在一个 msAvFlags，用于告知服务器是否要校验 MIC，当 msAvFlags 为 0x00000002 且服务器未收到 MIC 时，此次认证将被判定为失败：\n遗憾的是，攻击者无法将此 Flag 设为 0x00000000 以绕过 MIC，这是由于 Flag 参与了计算 NTProofStr 的过程，它也是整个加密字符串中的一部分，因此如果修改了此 Flag，则最终服务端将无法正确验证 NTProofStr，同样将导致认证失败。\nMIC 保护了三条消息的完整性，而 msAvFlags（0x00000002）则保证了 MIC 的存在，此时由于攻击者不知道认证用户的 NTLM-Hash，因此他什么也做不了。\nCVE-2019-1040 Preempt 团队发现了一个用于绕过 MIC 校验机制的漏洞，编号为 CVE-2019-1040，也被称为 Drop the MIC，此漏洞已经被集成于 impacket 中，只需要再调用 ntlmrelayx 时添加一个 \u0026ndash;remove-mic 参数即可使用，具体调用代码如下：\nif self.serverConfig.remove_mic: authMessage = NTLMAuthChallengeResponse() authMessage.fromString(authenticateMessageBlob) if authMessage[\u0026#39;flags\u0026#39;] \u0026amp; NTLMSSP_NEGOTIATE_SIGN == NTLMSSP_NEGOTIATE_SIGN: authMessage[\u0026#39;flags\u0026#39;] ^= NTLMSSP_NEGOTIATE_SIGN if authMessage[\u0026#39;flags\u0026#39;] \u0026amp; NTLMSSP_NEGOTIATE_ALWAYS_SIGN == NTLMSSP_NEGOTIATE_ALWAYS_SIGN: authMessage[\u0026#39;flags\u0026#39;] ^= NTLMSSP_NEGOTIATE_ALWAYS_SIGN if authMessage[\u0026#39;flags\u0026#39;] \u0026amp; NTLMSSP_NEGOTIATE_KEY_EXCH == NTLMSSP_NEGOTIATE_KEY_EXCH: authMessage[\u0026#39;flags\u0026#39;] ^= NTLMSSP_NEGOTIATE_KEY_EXCH if authMessage[\u0026#39;flags\u0026#39;] \u0026amp; NTLMSSP_NEGOTIATE_VERSION == NTLMSSP_NEGOTIATE_VERSION: authMessage[\u0026#39;flags\u0026#39;] ^= NTLMSSP_NEGOTIATE_VERSION authMessage[\u0026#39;MIC\u0026#39;] = b\u0026#39;\u0026#39; authMessage[\u0026#39;MICLen\u0026#39;] = 0 authMessage[\u0026#39;Version\u0026#39;] = b\u0026#39;\u0026#39; authMessage[\u0026#39;VersionLen\u0026#39;] = 0 通过置空（置零）的方式删除了 NTLM_AUTHENTICATE 消息中的 MIC、MICLen、Version、VersionLen 字段，此时即可成功的绕过 服务端对于 MIC 的校验。\n通过同样的方式删除（置零）了 NTLM_NEGOTIATE 消息中的 NTLMSSP_NEGOTIATE_ALWAYS_SIGN、NTLMSSP_NEGOTIATE_SIGN 和 NTLM_AUTHENTICATE 消息中的 NTLMSSP_NEGOTIATE_ALWAYS_SIGN、NTLMSSP_NEGOTIATE_SIGN、NEGOTIATE_KEY_EXCHANGE、NEGOTIATE_VERSION 字段，由于没有了 MIC，服务端不会对三条消息是否被篡改过进行验证，从而绕过 LDAP 签名实现 relay to LDAP。\nEPA 为了对抗跨协议 Relay 使 NTLM Relay 的危害降级，微软引入了被称为 EPA 的保护措施，这种保护的原理是将身份验证层与正在使用的协议绑定在一起，甚至与存在的 TLS 层绑定在一起(例如 LDAPS 或 HTTPS)，一般情况下，它将在最后一条 AUTHENTICATE 消息中放置一条信息，攻击者无法修改它，此信息指明了本次调用的服务（SMB、HTTP、LDAP）以及可能包含的证书等其它信息，EPA 通过服务绑定和 TLS 绑定两种方式防御跨协议 Relay。\nService Binding 如上图所示，Client 在 AUTHENTICATE 消息的 Response 中加入了 Target Name 这么一个属性，其中包含了 Client 想要调用的服务以及对应的 Client HostName，它也参与了 NTProofStr 的加密（可以理解为受到 NTProofStr 的保护），因此攻击者无法修改这个属性。\n因此如果攻击者想调用的服务收到了此消息，并且它发现了自身提供的服务与 AUTHENTICATE 消息中的不同，那么就会拒绝提供服务，除此之外，Server 还将检查此次服务调用的 IP 与属性中是否一致，如果不一致同样会拒绝提供服务，幸运的是目前 EPA 并不是作为默认情况被使用，如果需要使用这种保护措施需要手动设置，参考 KB5005413。\nTLS Binding 如果客户端希望与封装在 TLS 中的协议如 HTTPS、LDAPS 建立会话，那么它将计算服务端的证书 Hash，并将此 Hash 存放在 Response 中，攻击者无法修改此属性，因此当攻击者尝试进行 relay 攻击时，服务端发现 Response 中的 Hash 与自身不符（如 HTTPS relay LDAPS），或是服务端没有使用 TLS（LDAP、SMB）却在 Response 中发现了 证书 Hash（SMB relay LDAPS、SMB relay HTTPS \u0026hellip;），在遇到这两种情况时服务端都将拒绝提供服务。\nEPA \u0026ldquo;Bypass\u0026rdquo; 网上目前流传了两篇文章用于介绍如何绕过 EPA 的，一篇是 geekby 另一篇则是 bypass-epa-ntlm-attacks-wia ，说实话我不能理解为什么这被称为 Bypass，因为这种 Bypass 方式需要攻击者拥有用户哈希为前提的，但如果我有用户哈希了，为什么还要使用 NTLM Relay 呢？不过我倒是搜到了一个 CVE-2020-17162，关于这个漏洞网上还没有任何细节。\nIt is a bypass of Extended Protection for Authentication(EPA) where Service Principle Name could allow Windows store UAP applications to elevate privileges.\n总结 上面记录了能够防御 NTLM Relay 的四种方式，其中 ms08-068 阻止了攻击者 Relay To Self 的操作，而剩余三个防御均是用来防御 Relay To Other（Or Protocol）的操作，EPA 较之签名来说防御的更加全面一些，因此如果想真正做到完美防御 NTLM Relay，建议直接使用 EPA 作为防御机制，以及一处不知道是否已经实施的安全通告。\n微软于 2019-09-11 日发布相关通告称微软计划于 2020 年 1 月发布安全更新。为了提升域控制器的安全性，该安全更新将强制开启所有域控制器上 LDAP channel binding 与 LDAP signing 功能。\nReference NT LAN Manager (NTLM) Authentication Protocol Ghost-Potato NTLM Relay ","date":"2022-03-17T16:27:29+08:00","permalink":"https://tlmn-local.github.io/2022/03/17/ntlm-protocol/","title":"NTLM Protocol"}]