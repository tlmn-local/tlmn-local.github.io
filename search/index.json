[{"content":"概述 NTLM 是 Windows 众多认证协议之一，早期曾是 Windows 主要的认证方式，即使在后来 Kerberos 取代了 NTLM 作为首选的身份认证协议，但还是有很多场景必然需要使用到 NTLM 进行身份认证，包括但不限于：\n 其中一方不支持 Kerberos 其中一方未加入域中（工作组环境） 应用程序选择使用 NTLM 作为认证协议（如部分 HTTP、SMB、SMTP、MSSQL\u0026hellip;）  可以发现 NTLM 在现在也有着大量的使用场景，因此研究它的原理、脆弱性及修复方式也是很有必要的，无论你是作为攻击者或是防守方。\nNTLM 是一种基于挑战/响应的身份认证协议，这里需要注意一点，NTLM 是作为第三方模块单独嵌入到应用程序中使用的，应用程序使用 NTLM 进行身份认证，并将会话层与认证层相互隔离，认证细节对应用程序是透明的，这种认证方式是一把双刃剑，后文中会谈到。\n下图是客户端与服务端在通信过程中使用 NTLM 进行认证的一般流程，可以发现 NTLM Message 是嵌入到应用程序正常的 Message 中的：\nNTLM 有着悠久的发展历史，作为 Windows 最早的认证协议之一，其有着多个历史版本，包括 LM、NTLMv1 和 NTLMv2，几个版本的认证流程基本相同，区别仅在于计算 Response 的方式与设置了哪些 Response 字段。\n两种模式 NTLM 对于连接是否保持（TCP、UDP）设计了两种认证模式，一种是面向连接的，另一种则是无连接的，前者是目前用的最多的模式（因为大部分使用 NTLM 作为认证协议的应用均采用 TCP 进行数据传输）。\n面向连接的认证流程如下：\n首先是客户端与服务端会进行正常通信，随后客户端发起 NEGOTIATE 消息告知服务端开始认证，服务端发送 CHALLENGE 消息告知客户端 Challenge，客户端计算后得到 Response 并发送 AUTHENTICATE 消息进行认证，注意最后一条 Application message 不代表服务端不告知客户端认证结果，而是因为认证结果以何种形式发送是由应用程序决定的，此时已经与 NTLM 无关了。\n无连接的认证流程如下：\n从上述认证流程上看，虽然是服务端先向客户端发送了 Challenge，但实际上是由客户端通过应用程序自定义的某种消息先启动了认证流程，从整体上看与面向连接的认证方式基本一致，只不过第一步转为了应用程序自定义的消息。\n上面说了 NTLM 存在多个版本，其中 LM 已经基本废弃，较为常用的是 NTLMv1 与 NTLMv2 两个版本，至于使用哪个版本进行认证，则需要客户端与服务端共同设置，通常这里不会进行协商，而是直接在应用程序中写成固定代码。\nHash Windows 中不会存储用户密码的明文，只会存储其 Hash（后文称为哈希），本地用户的密码哈希存放于当前机器的 SAM 文件中，域用户的密码哈希则存放于域控制器（Domain Controller）的 NTDS.DIT 文件中，默认情况下这两个文件是不可访问的，但可利用其它方式将哈希导出。\n用户哈希通常由 LM-Hash 与 NT-Hash 两部分组成，其中 LM-Hash 是 Windows 最早使用的加密算法，核心使用了 DES 算法进行加密，由于 LM-Hash 存在较多的安全风险，于是从 Windows Vista 和 Windows Server 2008 开始，Windows 默认禁用了 LM-Hash，只启用 NT-Hash（有的文中也将其称为 NTLM-Hash 或是 NTLM，为了避免与协议名称混淆，这里记为 NT-Hash），因此在大多数操作系统中我们获取到的哈希可能是这样的：\n{Username}:{SID}:AAD3B435B51404EEAAD3B435B51404EE:62f83cc8d728c97df1e3b0a94e5c3ef9 其中 AAD3B435B51404EEAAD3B435B51404EE 为 LM-Hash，62f83cc8d728c97df1e3b0a94e5c3ef9 为 NT-Hash，如果某用户没有设置密码或当前的操作系统设置为不存储 LM-Hash，那么所获取到的 LM-Hash 就是 AAD3B435B51404EEAAD3B435B51404EE ，可以理解为空值，此哈希并没有价值，但某些工具要求输入格式为 {LM-Hash}:{NT-Hash} ，此时可将其设置为 0 值：00000000000000000000000000000000:{NT-Hash} 即可。\n备注：\n SAM Path：C:\\Windows\\System32\\config\\SAM NTDS.DIT Path：%SystemRoot%\\NTDS\\ntds.dit  LM-Hash 加密算法 LM Hash 的加密算法如下：\n 将所有字符转换为大写并转换为十六进制 如果长度不足14字节则在右侧填充 NULL 补充 将字符串分割为两个7字节的 chunk 将两个 chunk 分别先转为十六进制再转二进制 如果 chunk 的长度不到56则将其分割为7位一组并在每组末尾加0（最后一组除外） 将结果转为二进制后再转十六进制 去除开头的 0x 部分 以及右侧 L 字符后再次将两个 chunk 分别转为十六进制 将两个 chunk 分别作为 key 通过 DES 加密 KGS!@#$% 字符串 将加密结果合并，得到最终的 LM-Hash  转换为 Python 代码如下（Python3）：\nimport binascii from pyDes import * def encode_des(data, key): key = des(key, ECB, pad=None) encrypt_data = key.encrypt(data) return binascii.b2a_hex(encrypt_data) def padding_zero(data): result = [] length = len(data) for i in range(length): if i % 7 == 0: result.append(data[i:i + 7] + \u0026#39;0\u0026#39;) return \u0026#39;\u0026#39;.join(result) def get_lm_hash(password): password = password.upper() # 转换为大写 hex_password = str(binascii.b2a_hex(password.encode(\u0026#39;utf-8\u0026#39;)), encoding=\u0026#39;utf-8\u0026#39;) # 转换为十六进制字符串 hex_password = hex_password.ljust(28, \u0026#39;0\u0026#39;) # 不足十四字节的部分用0补全 # 将十六进制字符串分为两个部分，每部分有七个字节 hex_password_part_one = hex_password[0:14] hex_password_part_two = hex_password[14:28] # 将这两部分分别先转为十六进制再转为二进制 hex_password_part_one = bin(int(hex_password_part_one, 16)) hex_password_part_two = bin(int(hex_password_part_two, 16)) # 将这两部分分别用0左填充长度至56 hex_password_part_one = hex_password_part_one.lstrip(\u0026#39;0b\u0026#39;).rjust(56, \u0026#39;0\u0026#39;) hex_password_part_two = hex_password_part_two.lstrip(\u0026#39;0b\u0026#39;).rjust(56, \u0026#39;0\u0026#39;) # 将两部分分别以7位一组，每组末尾加0（除最后一组） padding_part_one = padding_zero(hex_password_part_one) padding_part_two = padding_zero(hex_password_part_two) # 将结果转换为二进制后再转为十六进制 padding_part_one = hex(int(padding_part_one, 2)) padding_part_two = hex(int(padding_part_two, 2)) # 去除开头的0x部分以及右侧的L字符 padding_part_one = padding_part_one[2:].rstrip(\u0026#39;L\u0026#39;) padding_part_two = padding_part_two[2:].rstrip(\u0026#39;L\u0026#39;) # 如果part_2为0x0，则将其转换为0000000000000000进行适配 if padding_part_two == \u0026#39;0\u0026#39;: padding_part_two = \u0026#39;0000000000000000\u0026#39; # 将其转换为十六进制 padding_part_one = binascii.a2b_hex(padding_part_one) padding_part_two = binascii.a2b_hex(padding_part_two) # 将每个部分作为key加密KGS!@#$%字符串 lm_part_one = encode_des(\u0026#34;KGS!@#$%\u0026#34;, padding_part_one) lm_part_two = encode_des(\u0026#34;KGS!@#$%\u0026#34;, padding_part_two) # 两组des加密结果拼接在一起，就是最终的结果 final_lm_hash = str(lm_part_one + lm_part_two, encoding=\u0026#39;utf-8\u0026#39;) return final_lm_hash if __name__ == \u0026#39;__main__\u0026#39;: print(get_lm_hash(\u0026#39;\u0026lt;password\u0026gt;\u0026#39;)) 从代码上看，LM-Hash 存在许多脆弱的设计，如：\n 不区分大小写 密码长度不能超过14位 使用分组拼接的方式计算 Hash，在得到 Hash 后也可使用分组爆破的方式还原密码，并且如果密码小于7位则后半段加密字符串必然是 aad3b435b51404ee  NT-Hash 加密算法 NT Hash 的加密算法的计算步骤较之LM Hash则简单许多：MD4(UTF-16-LE(password))，转换为Python代码如下：\nimport hashlib import binascii password = \u0026#39;\u0026lt;password\u0026gt;\u0026#39; print(str(binascii.hexlify(hashlib.new(\u0026#39;md4\u0026#39;,password.encode(\u0026#39;utf-16le\u0026#39;)).digest()),encoding=\u0026#39;utf-8\u0026#39;)) 验证 对测试密码 DC082!@# 进行加密计算 LM-Hash 与 NT-Hash，所得结果与图中一致：\n$ python3 lm_hash.py a0ecede8e75ed1b4c2a20cae7226e17d $ python3 nt_hash.py cdf300d7f4c17e59e3b96a05794aa007 NTLM 微软最早使用的认证协议是使用 LM-Hash 作为密钥的 LM，在上面曾提及 LM-Hash 存在诸多安全隐患，因此微软于1993年 Windows NT 3.1 中引入了 NTLMv1，并加入了 NT-Hash，此时 LM-Hash 与 NT-Hash 将共同使用，同时为了一定程度缓解重放攻击，微软在 Windows NT 4.0.SP4 中引入了 NTLMv2；本文将结合 SMB 的调用流程来对 NTLM 的认证过程进行实际分析（这里不区分v1或是v2，两个版本认证流程一致）。\n使用命令 net use \\\\192.168.2.110 \u0026quot;Admin!@#$~!@#01\u0026quot; /user:\u0026quot;Administrator\u0026quot; 尝试通过 SMB 协议链接 192.168.2.110 的共享资源，其中与 NTLM 认证有关的是图中圈起来的四条消息：\n首先客户端发送 NEGOTIATE 消息启动认证流程，此消息会对本次认证中使用的安全机制进行协商(flag)，并将客户端的域名和工作组名一同传递给服务端：\n随后服务端饭后 CHALLENGE 消息和 MORE_PROCESSING_REQUIRED 状态码告知客户端还需要传递用户信息以进行接下来的认证，CHALLENGE 中包含诸多来自服务端的信息，包括最重要的 Challenge、Timestamp（用于缓解重放攻击）和服务端机器的相关信息（机器名、域名、DNS 域名及 DNS 机器名：\n当客户端收到这一条消息后，会从中提取出 challenge，并使用用户提供的密码生成对应的 NT-Hash 以及 LM-Hash，并使用对应的 Hash 对 challenge 和其余信息合并后进行加密，最终得到一个加密串，具体处理代码如下（伪代码）。\nNTLMv1：\n-- -- Functions Used: -- Z(M)- Defined in section 6. Define NTOWFv1(Passwd, User, UserDom) as MD4(UNICODE(Passwd)) EndDefine Define LMOWFv1(Passwd, User, UserDom) as ConcatenationOf( DES( UpperCase( Passwd)[0..6],\u0026#34;KGS!@#$%\u0026#34;), DES( UpperCase( Passwd)[7..13],\u0026#34;KGS!@#$%\u0026#34;)) EndDefine Set ResponseKeyNT to NTOWFv1(Passwd, User, UserDom) Set ResponseKeyLM to LMOWFv1( Passwd, User, UserDom ) Define ComputeResponse(NegFlg, ResponseKeyNT, ResponseKeyLM, CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge, Time, ServerName) As If (User is set to \u0026#34;\u0026#34; AND Passwd is set to \u0026#34;\u0026#34;) -- Special case for anonymous authentication Set NtChallengeResponseLen to 0 Set NtChallengeResponseMaxLen to 0 Set NtChallengeResponseBufferOffset to 0 Set LmChallengeResponse to Z(1) ElseIf If (NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY flag is set in NegFlg) Set NtChallengeResponse to DESL(ResponseKeyNT, MD5(ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge))[0..7]) Set LmChallengeResponse to ConcatenationOf{ClientChallenge, Z(16)} Else Set NtChallengeResponse to DESL(ResponseKeyNT, CHALLENGE_MESSAGE.ServerChallenge) If (NoLMResponseNTLMv1 is TRUE) Set LmChallengeResponse to NtChallengeResponse Else Set LmChallengeResponse to DESL(ResponseKeyLM, CHALLENGE_MESSAGE.ServerChallenge) EndIf EndIf EndIf Set SessionBaseKey to MD4(NTOWF) NTLMv2：\nDefine NTOWFv2(Passwd, User, UserDom) as HMAC_MD5( MD4(UNICODE(Passwd)), UNICODE(ConcatenationOf( Uppercase(User), UserDom ) ) ) EndDefine Define LMOWFv2(Passwd, User, UserDom) as NTOWFv2(Passwd, User, UserDom) EndDefine Set ResponseKeyNT to NTOWFv2(Passwd, User, UserDom) Set ResponseKeyLM to LMOWFv2(Passwd, User, UserDom) Define ComputeResponse(NegFlg, ResponseKeyNT, ResponseKeyLM, CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge, Time, ServerName) As If (User is set to \u0026#34;\u0026#34; \u0026amp;\u0026amp; Passwd is set to \u0026#34;\u0026#34;) -- Special case for anonymous authentication Set NtChallengeResponseLen to 0 Set NtChallengeResponseMaxLen to 0 Set NtChallengeResponseBufferOffset to 0 Set LmChallengeResponse to Z(1) Else Set temp to ConcatenationOf(Responserversion, HiResponserversion, Z(6), Time, ClientChallenge, Z(4), ServerName, Z(4)) Set NTProofStr to HMAC_MD5(ResponseKeyNT, ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge,temp)) Set NtChallengeResponse to ConcatenationOf(NTProofStr, temp) Set LmChallengeResponse to ConcatenationOf(HMAC_MD5(ResponseKeyLM, ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge)), ClientChallenge ) EndIf Set SessionBaseKey to HMAC_MD5(ResponseKeyNT, NTProofStr) EndDefine 对比一下两者的加密算法，可以发现 NTLMv1 的加密较为简单，NTLMv2 的加密中除了 challenge 外还会将大量信息通过连接起来最后才进行加密，同时使用了 HMAC_MD5 进行以保护数据的完整性。\n可以发现 NTLMv1 是不存在 NTProofStr 这个数据的，因此也可以通过是否存在 NTProofStr 来判断当前认证使用的是哪个版本，下面是 SMB2 中使用 NTLMv2 进行认证的 AUTHENTICATE 消息：\n这里的 NTLMv2 Response 中的每一个字段都是受到 NTProofStr 保护的，因为 NTProofStr 是根据这些字段值和 challenge 生成出来的，因此新增或是修改其中任何一个字段都会导致服务端最后校验 NTProofStr 不成功，因为攻击者无法在没有 Hash 的情况 下重新生成 NTProofStr，这点很重要，也算是 NTLMv2 的一种保护机制。\n当服务端收到客户端的 Response 后，可根据服务端环境分为两种不同的处理方式：\n 在域环境中，服务端将 Challenge、Response Username 等信息发送给 DC，由 DC 调用 NTOWFv2 、LMOWFv2 对存储于 DC 上的域成员哈希计算对应的 NTProofStr 和 LM-Response，如果与客户端传递过来的相同则认证通过，反之则不通过 在工作组环境中，服务端调用 NTOWFv2 、LMOWFv2 对存储于服务端机器上的用户哈希计算对应的 NTProofStr 和 LM-Response，如果与客户端传递过来的相同则认为认证通过，反之则不通过  NTLM Relay NTLM 有着许多的攻击面，包括诸如哈希传递（PTH）、哈希爆破等，但这些都是与哈希有关的，本文只记录与协议有关的一种攻击手法，即 NTLM Relay。\n从 NTLM 的认证流程可以看出，服务端会对客户端的身份进行认证，然而客户端并不会对服务端的身份进行认证（即单向认证），也正是因为这种单向认证，才产生了 NTLM Relay 这种中间人攻击的手法。\n正常的认证流程是向下图这样的：\n假设攻击者有能力作为中间人的身份存在于客户端与服务端之间（也就是能够让客户端主动向攻击者发起 NTLM 认证请求），此时攻击者只需要简单的转发数据包，即可以客户端的身份调用服务端所提供的服务：\n以服务器的角度看，它已经完成了对客户端的身份验证，并且完全无法意识到此时的通信中存在着中间人，当身份认证完成后，攻击者可使用服务端下发的认证凭据以客户端的身份调用其对外提供的服务。\n如果根据 Relay 的对象来区分，可以得出一个结论：工作组环境通常是 Relay 回自身以获得主机权限，域环境较之工作组环境扩充了许多玩法，此时则不仅局限于 Relay 自身，通常还可 Relay 至 DC 以实现其它操作。\n现假设存在 A、B、C 三台主机，假设 A 和 C 上存在着某个用户名和密码均相同的用户（如 Administrator），攻击者获取到了 B 的权限并且通过某种方式可以让 A 主动发起 SMB 请求，那么攻击者可以在 B 上架设一个恶意的中转 SMB 服务器，此时 B 上获得 A 的 NTLM 认证请求并将其转发至 C 的 SMB 服务（无跨协议），从而获得 C 的主机权限，impacket 的 ntlmrelayx.py 已经很好的集成了 ntlm relay 的大部分玩法：\n上面是我通过 impacket 启动了一个恶意的 SMB 服务，并将认证请求转发给 192.168.2.112（C） 这台主机，成功认证后会在本地创建一个代理，后序我可通过此代理调用目标的 SMB 服务，比如通过 smbexec.py 实现命令执行：\n看流量图也许能够更好的理解 NTLM Relay：\n在上图中，A 主机（192.168.2.113）向 B 主机（192.168.2.109）发出的消息会被修改（修改部分 Client 信息）后转发到 C 主机（192.168.2.112），随后将 C 主机的响应修改部分信息后转发给 B 主机。\n上面多次提到了跨协议，为什么 NTLM Relay 能够跨协议呢？这是因为 NTLM 是一个嵌入式协议，无论对于哪个上层应用来说它的认证方式是不变的，不会受到上层应用的影响，因此当攻击者收到一个 SMB 的 NTLM 认证后，可转发给其它机器的 LDAP 或是其它服务进行认证。\n防御措施 上面介绍了 NTLM Relay 的攻击原理与攻击场景，接下来将主要分析微软对于 NTLM Relay 的多种防御措施，其中有几种防御措施相辅相成，相互关联，十分精彩！\nms08-068 NTLM Relay 不仅可以 Relay 到其它机器，在工作组环境下也可以 Relay 到发出请求的机器已获得其主机权限，如下图所示：\n微软在2008年发布了 ms08-068 补丁用于缓解这种 Relay To Self 的场景，它是怎么工作的呢？根据文档描述，SMB 客户端在进行认证时需要循环调用 InitializeSecurityContext直到其返回 SEC_E_OK 才表示认证成功，ms08-068 的修复方式是将调用函数过程中传递的 pszTargetName 由原先的 null 修改为服务端具体服务的SPN，即当我们想访问 \\\\smb-server\\share  时，此处会被设置为 cifs/smb-server 。\n接下来要介绍一下 challenge cache 机制，它是能够防御 Relay To Self 的核心原因，当然需要搭配 pszTargetName 进行使用，下面是被防御的场景，假设 A 是受害者的机器，B 是 攻击者的机器，攻击者通过某种方式让 A 向其发起了 SMB 请求，并希望 Relay To A：\nA --\u0026gt; B --\u0026gt; A-SMB （NEGOTIATE） A-SMB --\u0026gt; B --\u0026gt; A （CHALLENGE），此处当 A 收到 challenge 后，会将 challenge 与 B 的 SPN 一同缓存 A --\u0026gt; B --\u0026gt; A-SMB （Response），当 A 的 SMB 服务收到 Response后，会判断 challenge 是否在本地存在，如果存在并且 SPN 不为本机， 则认为此次 Response 为 NTLM Relay 转发过来的，因此认证失败 CVE-2019-1384（Ghost Potato） CVE-2019-1384 则是用于绕过 ms08-068 的攻击手法，由于缓存至多存在300s，过了300s缓存就会自动被删除，因此只需要将 SMB 的请求一直保持，等待300s后再发送 Response 即可成功绕过 ms08-068 的防御。\n微软在 2019年12月11日 发布了修复此漏洞的补丁：CVE-2019-1384 。\n会话签名 正如之前说的一样，NTLM 只是身份认证层的实现，当身份认证完毕后，应用层协议会继续使用它们的协议规范进行服务的调用，后续服务调用的过程被称为会话层，会话签名是基于用户 Hash 生成的，因此攻击者无法伪造。\n当认证完毕后，如果存在客户端与服务的协商的决定是要对后续所有会话进行签名，那么攻击者将无法利用 Relay ，因为攻击者无法修改会话时所调用服务的 Action 或是 Relay 去其它协议，下图是基于会话签名保护的服务调用流程：\n下图是基于会话签名保护的 NTLM Relay 流程：\n由于后续攻击者必然想调用自定义的 Action（如 smbexec），但由于攻击者没有办法生成会话签名，因此服务端对签名的校验失败，将拒绝提供服务。\nSMB Signing SMB 协议的会话签名是在 SMB 协议中实现的，不涉及 NTLM，是否需要进行签名实际上是客户端与服务端在 NTLM 认证前就已经协商好了的，首先客户端会向服务端发送一条 NEGOTIATE 消息以告知服务端其对签名的处理方式（注意此处的 NEGOTIATE 与 NTLM 无关，是 SMB 协议自己的 NEGOTIATE）：\n随后服务端会在 NEGOTIATE Response 中告知其对签名的处理方式：\n可以发现此时客户端与服务端的处理方式都是 enable，那么它们到底是签名还是不签名呢？微软官方提供了一个矩阵用于确定 客户端、服务端、NTLM 版本为何值时需要进行签名，并且其中包含一系列额外条件，如域控制器是强制签名的之类。\n通过上面的矩阵可以得出本次是否签名的结论，由于此次使用的是 SMBv2 协议，并且对话的双方均不是域控制器，因此后续会话将不进行签名验证。\n当客户端向域控制器验证身份时是需要签名的，但当域控制器向另外一台域控制器验证身份时则是不需要签名的。\n总结一下整个流程：\n 对应的上层协议在 NEGOTIATE 消息中告知对方其对签名的处理方式 Client 在 NTLM NEGOTIATE 消息中告知 Server 其是否支持签名，Server 在 NTLM Challenge 中告知 Client 其是否支持签名 Client 认证完毕，发起后续会话，如果前面一系列的协商结果为需要签名，则 Client 会在后续流量中添加一个 Signature 字段用于签名，Server 与 Client 的处理方式一致  LDAP Signing 在调用 LDAP 服务时，客户端与服务端同样有着 3 个选项来协商是否需要进行签名：\n Disabled：不支持数据包签名 Negotiated：可以处理签名，但不要求一定要签名 Required：必须对数据包进行签名  LDAP 是在 NTLM 认证时进行签名协商的，首先在 NTLM NEGOTIATE 消息中，客户端会设置 Flag 表示其能够处理签名：\n随后服务端会在 CHALLENGE 消息中设置 Flag 以告知其是否能够处理签名：\n由于默认情况下除了域控外的所有主机最终的协商均为 Negotiated（两台服务器均能够处理签名），这也表示正常情况下认证完毕后的所有 LDAP 流量均受签名的保护。\n可以发现 SMB 与 LDAP 的区别，SMB 的签名协商是发生在 SMB 协议上的，而 LDAP 的签名协商则是发生在 NTLM 认证时的，那是否意味着只要攻击者将 Negotiate Sign 设置为 False 即可绕过签名？可惜的是，NTLM 也有自己的消息完整性验证机制，即后文要介绍的 MIC。\nMIC MIC（Message Integrity Code）的主要目的是为了保证数据的完整性，即从客户端发出去是什么数据就应该在服务端收到什么数据，它只包含在 NTLM 认证流程中的最后一条消息（AUTHENTICATE）中被发出，算法如下：\nHMAC_MD5(Session key, NEGOTIATE_MESSAGE + CHALLENGE_MESSAGE + AUTHENTICATE_MESSAGE) 由于 Session Key 是由用户的 Hash 所加密得到的，这也就意味着攻击者没有办法重新计算 MIC，而 MIC 中包含了三条消息，这也意味着攻击者没有办法修改前两条消息，因为这将导致服务端算出来的 MIC 无法正确校验。\n由于 MIC 是可选的，因此在转发数据包的过程中可以将 MIC 删除，但这是无效的，因为在 AUTHENTICATE 消息中还存在一个 msAvFlags，用于告知服务器是否要校验 MIC，当 msAvFlags 为 0x00000002 且服务器未收到 MIC 时，此次认证将被判定为失败：\n遗憾的是，攻击者无法将此 Flag 设为 0x00000000 以绕过 MIC，这是由于 Flag 参与了计算 NTProofStr 的过程，它也是整个加密字符串中的一部分，因此如果修改了此 Flag，则最终服务端将无法正确验证 NTProofStr，同样将导致认证失败。\nMIC 保护了三条消息的完整性，而 msAvFlags（0x00000002）则保证了 MIC 的存在，此时由于攻击者不知道认证用户的 NTLM-Hash，因此他什么也做不了。\nCVE-2019-1040 Preempt 团队发现了一个用于绕过 MIC 校验机制的漏洞，编号为 CVE-2019-1040，也被称为 Drop the MIC，此漏洞已经被集成于 impacket 中，只需要再调用 ntlmrelayx 时添加一个 \u0026ndash;remove-mic 参数即可使用，具体调用代码如下：\nif self.serverConfig.remove_mic: authMessage = NTLMAuthChallengeResponse() authMessage.fromString(authenticateMessageBlob) if authMessage[\u0026#39;flags\u0026#39;] \u0026amp; NTLMSSP_NEGOTIATE_SIGN == NTLMSSP_NEGOTIATE_SIGN: authMessage[\u0026#39;flags\u0026#39;] ^= NTLMSSP_NEGOTIATE_SIGN if authMessage[\u0026#39;flags\u0026#39;] \u0026amp; NTLMSSP_NEGOTIATE_ALWAYS_SIGN == NTLMSSP_NEGOTIATE_ALWAYS_SIGN: authMessage[\u0026#39;flags\u0026#39;] ^= NTLMSSP_NEGOTIATE_ALWAYS_SIGN if authMessage[\u0026#39;flags\u0026#39;] \u0026amp; NTLMSSP_NEGOTIATE_KEY_EXCH == NTLMSSP_NEGOTIATE_KEY_EXCH: authMessage[\u0026#39;flags\u0026#39;] ^= NTLMSSP_NEGOTIATE_KEY_EXCH if authMessage[\u0026#39;flags\u0026#39;] \u0026amp; NTLMSSP_NEGOTIATE_VERSION == NTLMSSP_NEGOTIATE_VERSION: authMessage[\u0026#39;flags\u0026#39;] ^= NTLMSSP_NEGOTIATE_VERSION authMessage[\u0026#39;MIC\u0026#39;] = b\u0026#39;\u0026#39; authMessage[\u0026#39;MICLen\u0026#39;] = 0 authMessage[\u0026#39;Version\u0026#39;] = b\u0026#39;\u0026#39; authMessage[\u0026#39;VersionLen\u0026#39;] = 0 通过置空（置零）的方式删除了 NTLM_AUTHENTICATE 消息中的 MIC、MICLen、Version、VersionLen 字段，此时即可成功的绕过 服务端对于 MIC 的校验。\n通过同样的方式删除（置零）了 NTLM_NEGOTIATE 消息中的 NTLMSSP_NEGOTIATE_ALWAYS_SIGN、NTLMSSP_NEGOTIATE_SIGN 和 NTLM_AUTHENTICATE 消息中的 NTLMSSP_NEGOTIATE_ALWAYS_SIGN、NTLMSSP_NEGOTIATE_SIGN、NEGOTIATE_KEY_EXCHANGE、NEGOTIATE_VERSION 字段，由于没有了 MIC，服务端不会对三条消息是否被篡改过进行验证，从而绕过 LDAP 签名实现 relay to LDAP。\nEPA 为了对抗跨协议 Relay 使 NTLM Relay 的危害降级，微软引入了被称为 EPA 的保护措施，这种保护的原理是将身份验证层与正在使用的协议绑定在一起，甚至与存在的 TLS 层绑定在一起(例如 LDAPS 或 HTTPS)，一般情况下，它将在最后一条 AUTHENTICATE 消息中放置一条信息，攻击者无法修改它，此信息指明了本次调用的服务（SMB、HTTP、LDAP）以及可能包含的证书等其它信息，EPA 通过服务绑定和 TLS 绑定两种方式防御跨协议 Relay。\nService Binding 如上图所示，Client 在 AUTHENTICATE 消息的 Response 中加入了 Target Name 这么一个属性，其中包含了 Client 想要调用的服务以及对应的 Client HostName，它也参与了 NTProofStr 的加密（可以理解为受到 NTProofStr 的保护），因此攻击者无法修改这个属性。\n因此如果攻击者想调用的服务收到了此消息，并且它发现了自身提供的服务与 AUTHENTICATE 消息中的不同，那么就会拒绝提供服务，除此之外，Server 还将检查此次服务调用的 IP 与属性中是否一致，如果不一致同样会拒绝提供服务，幸运的是目前 EPA 并不是作为默认情况被使用，如果需要使用这种保护措施需要手动设置，参考 KB5005413。\nTLS Binding 如果客户端希望与封装在 TLS 中的协议如 HTTPS、LDAPS 建立会话，那么它将计算服务端的证书 Hash，并将此 Hash 存放在 Response 中，攻击者无法修改此属性，因此当攻击者尝试进行 relay 攻击时，服务端发现 Response 中的 Hash 与自身不符（如 HTTPS relay LDAPS），或是服务端没有使用 TLS（LDAP、SMB）却在 Response 中发现了 证书 Hash（SMB relay LDAPS、SMB relay HTTPS \u0026hellip;），在遇到这两种情况时服务端都将拒绝提供服务。\nEPA \u0026ldquo;Bypass\u0026rdquo; 网上目前流传了两篇文章用于介绍如何绕过 EPA 的，一篇是 geekby 另一篇则是 bypass-epa-ntlm-attacks-wia ，说实话我不能理解为什么这被称为 Bypass，因为这种 Bypass 方式需要攻击者拥有用户哈希为前提的，但如果我有用户哈希了，为什么还要使用 NTLM Relay 呢？不过我倒是搜到了一个 CVE-2020-17162，关于这个漏洞网上还没有任何细节。\n It is a bypass of Extended Protection for Authentication(EPA) where Service Principle Name could allow Windows store UAP applications to elevate privileges.\n Reference  NT LAN Manager (NTLM) Authentication Protocol Ghost-Potato NTLM Relay  ","date":"2022-03-17T16:27:29+08:00","permalink":"https://tlmn-local.github.io/2022/03/17/ntlm-protocol/","title":"NTLM Protocol"}]