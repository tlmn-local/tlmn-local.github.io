<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="概述 NTLM 是 Windows 众多认证协议之一，早期曾是 Windows 主要的认证方式，即使在后来 Kerberos 取代了 NTLM 作为首选的身份认证协议，但还是有很多场景必然需要使用到 NTLM 进行身份认"><title>NTLM Protocol</title><link rel=canonical href=https://tlmn-local.github.io/2022/03/17/ntlm-protocol/><link rel=stylesheet href=/scss/style.min.e59e4737e9dd560b6b5bac1009c39dfef009ff46df2811c1237b04dd210617ec.css><meta property="og:title" content="NTLM Protocol"><meta property="og:description" content="概述 NTLM 是 Windows 众多认证协议之一，早期曾是 Windows 主要的认证方式，即使在后来 Kerberos 取代了 NTLM 作为首选的身份认证协议，但还是有很多场景必然需要使用到 NTLM 进行身份认"><meta property="og:url" content="https://tlmn-local.github.io/2022/03/17/ntlm-protocol/"><meta property="og:site_name" content="今日明月夜"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="内网渗透"><meta property="article:published_time" content="2022-03-17T16:27:29+08:00"><meta property="article:modified_time" content="2022-03-17T16:27:29+08:00"><meta name=twitter:title content="NTLM Protocol"><meta name=twitter:description content="概述 NTLM 是 Windows 众多认证协议之一，早期曾是 Windows 主要的认证方式，即使在后来 Kerberos 取代了 NTLM 作为首选的身份认证协议，但还是有很多场景必然需要使用到 NTLM 进行身份认"></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/red-team/ style=background-color:#2a9d8f;color:#fff>红蓝对抗</a></header><h2 class=article-title><a href=/2022/03/17/ntlm-protocol/>NTLM Protocol</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Mar 17, 2022 16:27</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>17 minute read</time></div></footer></div></header><section class=article-content><h1 id=概述>概述</h1><p>NTLM 是 Windows 众多认证协议之一，早期曾是 Windows 主要的认证方式，即使在后来 Kerberos 取代了 NTLM 作为首选的身份认证协议，但还是有很多场景必然需要使用到 NTLM 进行身份认证，包括但不限于：</p><ul><li>其中一方不支持 Kerberos</li><li>其中一方未加入域中（工作组环境）</li><li>应用程序选择使用 NTLM 作为认证协议（如部分 HTTP、SMB、SMTP、MSSQL&mldr;）</li></ul><p>可以发现 NTLM 在现在也有着大量的使用场景，因此研究它的原理、脆弱性及修复方式也是很有必要的，无论你是作为攻击者或是防守方。</p><p>NTLM 是一种基于挑战/响应的身份认证协议，这里需要注意一点，<strong>NTLM 是作为第三方模块单独嵌入到应用程序中使用的</strong>，应用程序使用 NTLM 进行身份认证，并将会话层与认证层相互隔离，认证细节对应用程序是透明的，这种认证方式是一把双刃剑，后文中会谈到。</p><p>下图是客户端与服务端在通信过程中使用 NTLM 进行认证的一般流程，可以发现 NTLM Message 是嵌入到应用程序正常的 Message 中的：</p><img src=https://docs.microsoft.com/zh-cn/openspecs/windows_protocols/ms-nlmp/ms-nlmp_files/image001.png alt="Typical NTLM authentication message flow" style=zoom:150%><p>NTLM 有着悠久的发展历史，作为 Windows 最早的认证协议之一，其有着多个历史版本，<strong>包括 LM、NTLMv1 和 NTLMv2，几个版本的认证流程基本相同，区别仅在于计算 Response 的方式与设置了哪些 Response 字段。</strong></p><h1 id=两种模式>两种模式</h1><p>NTLM 对于连接是否保持（TCP、UDP）设计了两种认证模式，一种是面向连接的，另一种则是无连接的，前者是目前用的最多的模式（因为大部分使用 NTLM 作为认证协议的应用均采用 TCP 进行数据传输）。</p><p>面向连接的认证流程如下：</p><img src=https://docs.microsoft.com/zh-cn/openspecs/windows_protocols/ms-nlmp/ms-nlmp_files/image002.png alt="Connection-oriented NTLM message flow" style=zoom:150%><p>首先是客户端与服务端会进行正常通信，随后客户端发起 NEGOTIATE 消息告知服务端开始认证，服务端发送 CHALLENGE 消息告知客户端 Challenge，客户端计算后得到 Response 并发送 AUTHENTICATE 消息进行认证，<strong>注意最后一条 Application message 不代表服务端不告知客户端认证结果，而是因为认证结果以何种形式发送是由应用程序决定的，此时已经与 NTLM 无关了。</strong></p><p>无连接的认证流程如下：</p><img src=https://docs.microsoft.com/zh-cn/openspecs/windows_protocols/ms-nlmp/ms-nlmp_files/image003.png alt="Connectionless NTLM message flow" style=zoom:150%><p>从上述认证流程上看，<strong>虽然是服务端先向客户端发送了 Challenge，但实际上是由客户端通过应用程序自定义的某种消息先启动了认证流程</strong>，从整体上看与面向连接的认证方式基本一致，只不过第一步转为了应用程序自定义的消息。</p><p>上面说了 NTLM 存在多个版本，<strong>其中 LM 已经基本废弃，较为常用的是 NTLMv1 与 NTLMv2 两个版本</strong>，至于使用哪个版本进行认证，则需要客户端与服务端共同设置，通常这里不会进行协商，而是直接在应用程序中写成固定代码。</p><h1 id=hash>Hash</h1><p>Windows 中不会存储用户密码的明文，只会存储其 Hash（后文称为哈希），<strong>本地用户的密码哈希存放于当前机器的 SAM 文件中，域用户的密码哈希则存放于域控制器（Domain Controller）的 NTDS.DIT 文件中</strong>，默认情况下这两个文件是不可访问的，但可利用其它方式将哈希导出。</p><p>用户哈希通常由 LM-Hash 与 NT-Hash 两部分组成，其中 LM-Hash 是 Windows 最早使用的加密算法，核心使用了 DES 算法进行加密，由于 LM-Hash 存在较多的安全风险，于是从 Windows Vista 和 Windows Server 2008 开始，Windows 默认禁用了 LM-Hash，只启用 NT-Hash（<strong>有的文中也将其称为 NTLM-Hash 或是 NTLM，为了避免与协议名称混淆，这里记为 NT-Hash</strong>），因此在大多数操作系统中我们获取到的哈希可能是这样的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>{Username}:{SID}:AAD3B435B51404EEAAD3B435B51404EE:62f83cc8d728c97df1e3b0a94e5c3ef9
</span></span></code></pre></div><p>其中 <code>AAD3B435B51404EEAAD3B435B51404EE</code> 为 LM-Hash，<code>62f83cc8d728c97df1e3b0a94e5c3ef9</code> 为 NT-Hash，如果某用户没有设置密码或当前的操作系统设置为不存储 LM-Hash，那么所获取到的 LM-Hash 就是 <code>AAD3B435B51404EEAAD3B435B51404EE</code> ，可以理解为空值，此哈希并没有价值，但某些工具要求输入格式为 <code>{LM-Hash}:{NT-Hash}</code> ，此时可将其设置为 0 值：<code>00000000000000000000000000000000:{NT-Hash}</code> 即可。</p><p>备注：</p><ul><li>SAM Path：C:\Windows\System32\config\SAM</li><li>NTDS.DIT Path：%SystemRoot%\NTDS\ntds.dit</li></ul><h2 id=lm-hash-加密算法>LM-Hash 加密算法</h2><p>LM Hash 的加密算法如下：</p><ol><li>将所有字符转换为大写并转换为十六进制</li><li>如果长度不足14字节则在右侧填充 NULL 补充</li><li>将字符串分割为两个7字节的 chunk</li><li>将两个 chunk 分别先转为十六进制再转二进制</li><li>如果 chunk 的长度不到56则将其分割为7位一组并在每组末尾加0（最后一组除外）</li><li>将结果转为二进制后再转十六进制</li><li>去除开头的 0x 部分 以及右侧 L 字符后再次将两个 chunk 分别转为十六进制</li><li>将两个 chunk 分别作为 key 通过 DES 加密 <code>KGS!@#$%</code> 字符串</li><li>将加密结果合并，得到最终的 LM-Hash</li></ol><p>转换为 Python 代码如下（Python3）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>binascii</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pyDes</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>encode_des</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>key</span> <span class=o>=</span> <span class=n>des</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>ECB</span><span class=p>,</span> <span class=n>pad</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>encrypt_data</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=n>encrypt</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>binascii</span><span class=o>.</span><span class=n>b2a_hex</span><span class=p>(</span><span class=n>encrypt_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>padding_zero</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>length</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>length</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>%</span> <span class=mi>7</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>i</span> <span class=o>+</span> <span class=mi>7</span><span class=p>]</span> <span class=o>+</span> <span class=s1>&#39;0&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_lm_hash</span><span class=p>(</span><span class=n>password</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>password</span> <span class=o>=</span> <span class=n>password</span><span class=o>.</span><span class=n>upper</span><span class=p>()</span>  <span class=c1># 转换为大写</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_password</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>binascii</span><span class=o>.</span><span class=n>b2a_hex</span><span class=p>(</span><span class=n>password</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)),</span> <span class=n>encoding</span><span class=o>=</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)</span>  <span class=c1># 转换为十六进制字符串</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_password</span> <span class=o>=</span> <span class=n>hex_password</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mi>28</span><span class=p>,</span> <span class=s1>&#39;0&#39;</span><span class=p>)</span>  <span class=c1># 不足十四字节的部分用0补全</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将十六进制字符串分为两个部分，每部分有七个字节</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_password_part_one</span> <span class=o>=</span> <span class=n>hex_password</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>14</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_password_part_two</span> <span class=o>=</span> <span class=n>hex_password</span><span class=p>[</span><span class=mi>14</span><span class=p>:</span><span class=mi>28</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将这两部分分别先转为十六进制再转为二进制</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_password_part_one</span> <span class=o>=</span> <span class=nb>bin</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>hex_password_part_one</span><span class=p>,</span> <span class=mi>16</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_password_part_two</span> <span class=o>=</span> <span class=nb>bin</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>hex_password_part_two</span><span class=p>,</span> <span class=mi>16</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将这两部分分别用0左填充长度至56</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_password_part_one</span> <span class=o>=</span> <span class=n>hex_password_part_one</span><span class=o>.</span><span class=n>lstrip</span><span class=p>(</span><span class=s1>&#39;0b&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>rjust</span><span class=p>(</span><span class=mi>56</span><span class=p>,</span> <span class=s1>&#39;0&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_password_part_two</span> <span class=o>=</span> <span class=n>hex_password_part_two</span><span class=o>.</span><span class=n>lstrip</span><span class=p>(</span><span class=s1>&#39;0b&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>rjust</span><span class=p>(</span><span class=mi>56</span><span class=p>,</span> <span class=s1>&#39;0&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将两部分分别以7位一组，每组末尾加0（除最后一组）</span>
</span></span><span class=line><span class=cl>    <span class=n>padding_part_one</span> <span class=o>=</span> <span class=n>padding_zero</span><span class=p>(</span><span class=n>hex_password_part_one</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>padding_part_two</span> <span class=o>=</span> <span class=n>padding_zero</span><span class=p>(</span><span class=n>hex_password_part_two</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将结果转换为二进制后再转为十六进制</span>
</span></span><span class=line><span class=cl>    <span class=n>padding_part_one</span> <span class=o>=</span> <span class=nb>hex</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>padding_part_one</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>padding_part_two</span> <span class=o>=</span> <span class=nb>hex</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>padding_part_two</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 去除开头的0x部分以及右侧的L字符</span>
</span></span><span class=line><span class=cl>    <span class=n>padding_part_one</span> <span class=o>=</span> <span class=n>padding_part_one</span><span class=p>[</span><span class=mi>2</span><span class=p>:]</span><span class=o>.</span><span class=n>rstrip</span><span class=p>(</span><span class=s1>&#39;L&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>padding_part_two</span> <span class=o>=</span> <span class=n>padding_part_two</span><span class=p>[</span><span class=mi>2</span><span class=p>:]</span><span class=o>.</span><span class=n>rstrip</span><span class=p>(</span><span class=s1>&#39;L&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 如果part_2为0x0，则将其转换为0000000000000000进行适配</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>padding_part_two</span> <span class=o>==</span> <span class=s1>&#39;0&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>padding_part_two</span> <span class=o>=</span> <span class=s1>&#39;0000000000000000&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将其转换为十六进制</span>
</span></span><span class=line><span class=cl>    <span class=n>padding_part_one</span> <span class=o>=</span> <span class=n>binascii</span><span class=o>.</span><span class=n>a2b_hex</span><span class=p>(</span><span class=n>padding_part_one</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>padding_part_two</span> <span class=o>=</span> <span class=n>binascii</span><span class=o>.</span><span class=n>a2b_hex</span><span class=p>(</span><span class=n>padding_part_two</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将每个部分作为key加密KGS!@#$%字符串</span>
</span></span><span class=line><span class=cl>    <span class=n>lm_part_one</span> <span class=o>=</span> <span class=n>encode_des</span><span class=p>(</span><span class=s2>&#34;KGS!@#$%&#34;</span><span class=p>,</span> <span class=n>padding_part_one</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>lm_part_two</span> <span class=o>=</span> <span class=n>encode_des</span><span class=p>(</span><span class=s2>&#34;KGS!@#$%&#34;</span><span class=p>,</span> <span class=n>padding_part_two</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 两组des加密结果拼接在一起，就是最终的结果</span>
</span></span><span class=line><span class=cl>    <span class=n>final_lm_hash</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>lm_part_one</span> <span class=o>+</span> <span class=n>lm_part_two</span><span class=p>,</span> <span class=n>encoding</span><span class=o>=</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>final_lm_hash</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>get_lm_hash</span><span class=p>(</span><span class=s1>&#39;&lt;password&gt;&#39;</span><span class=p>))</span>
</span></span></code></pre></div><p>从代码上看，LM-Hash 存在许多脆弱的设计，如：</p><ul><li>不区分大小写</li><li>密码长度不能超过14位</li><li>使用分组拼接的方式计算 Hash，在得到 Hash 后也可使用分组爆破的方式还原密码，并且如果密码小于7位则后半段加密字符串必然是 <code>aad3b435b51404ee</code></li></ul><h2 id=nt-hash-加密算法>NT-Hash 加密算法</h2><p>NT Hash 的加密算法的计算步骤较之LM Hash则简单许多：<code>MD4(UTF-16-LE(password))</code>，转换为Python代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>hashlib</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>binascii</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>password</span> <span class=o>=</span> <span class=s1>&#39;&lt;password&gt;&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>binascii</span><span class=o>.</span><span class=n>hexlify</span><span class=p>(</span><span class=n>hashlib</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=s1>&#39;md4&#39;</span><span class=p>,</span><span class=n>password</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s1>&#39;utf-16le&#39;</span><span class=p>))</span><span class=o>.</span><span class=n>digest</span><span class=p>()),</span><span class=n>encoding</span><span class=o>=</span><span class=s1>&#39;utf-8&#39;</span><span class=p>))</span>
</span></span></code></pre></div><h2 id=验证>验证</h2><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h04u4d00sgj210h0u0gqg.jpg loading=lazy alt=verify-hash></p><p>对测试密码 <code>DC082!@#</code> 进行加密计算 LM-Hash 与 NT-Hash，所得结果与图中一致：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python3 lm_hash.py
</span></span><span class=line><span class=cl>a0ecede8e75ed1b4c2a20cae7226e17d
</span></span><span class=line><span class=cl>$ python3 nt_hash.py                                               
</span></span><span class=line><span class=cl>cdf300d7f4c17e59e3b96a05794aa007
</span></span></code></pre></div><h1 id=ntlm>NTLM</h1><p>微软最早使用的认证协议是使用 LM-Hash 作为密钥的 LM，在上面曾提及 LM-Hash 存在诸多安全隐患，因此微软于1993年 Windows NT 3.1 中引入了 NTLMv1，并加入了 NT-Hash，此时 LM-Hash 与 NT-Hash 将共同使用，同时为了一定程度缓解重放攻击，微软在 Windows NT 4.0.SP4 中引入了 NTLMv2；本文将结合 SMB 的调用流程来对 NTLM 的认证过程进行实际分析（这里不区分v1或是v2，两个版本认证流程一致）。</p><p>使用命令 <code>net use \\192.168.2.110 "Admin!@#$~!@#01" /user:"Administrator"</code> 尝试通过 SMB 协议链接 192.168.2.110 的共享资源，其中与 NTLM 认证有关的是图中圈起来的四条消息：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h08m2rbgfwj21c00u0gw5.jpg loading=lazy alt=image-20220313221258206></p><p>首先客户端发送 NEGOTIATE 消息启动认证流程，此消息会对本次认证中使用的安全机制进行协商(flag)，并将客户端的域名和工作组名一同传递给服务端：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h08m7t0qclj21c00u0gut.jpg loading=lazy alt=image-20220313221749189></p><p>随后服务端饭后 CHALLENGE 消息和 MORE_PROCESSING_REQUIRED 状态码告知客户端还需要传递用户信息以进行接下来的认证，CHALLENGE 中包含诸多来自服务端的信息，<strong>包括最重要的 Challenge</strong>、Timestamp（用于缓解重放攻击）和服务端机器的相关信息（机器名、域名、DNS 域名及 DNS 机器名：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h08menarawj21c00u0ais.jpg loading=lazy alt=image-20220313222423456></p><p>当客户端收到这一条消息后，会从中提取出 challenge，并使用用户提供的密码生成对应的 NT-Hash 以及 LM-Hash，并使用对应的 Hash 对 challenge 和其余信息合并后进行加密，最终得到一个加密串，具体处理代码如下（伪代码）。</p><p>NTLMv1：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> --
</span></span><span class=line><span class=cl> -- Functions Used:
</span></span><span class=line><span class=cl> --   Z(M)- Defined in section 6.
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> Define NTOWFv1(Passwd, User, UserDom) as MD4(UNICODE(Passwd))
</span></span><span class=line><span class=cl> EndDefine
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> Define LMOWFv1(Passwd, User, UserDom) as
</span></span><span class=line><span class=cl>        ConcatenationOf( DES( UpperCase( Passwd)[0..6],&#34;KGS!@#$%&#34;),
</span></span><span class=line><span class=cl>                  DES( UpperCase( Passwd)[7..13],&#34;KGS!@#$%&#34;)) 
</span></span><span class=line><span class=cl> EndDefine
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> Set ResponseKeyNT to NTOWFv1(Passwd, User, UserDom)
</span></span><span class=line><span class=cl> Set ResponseKeyLM to LMOWFv1( Passwd, User, UserDom )
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> Define ComputeResponse(NegFlg, ResponseKeyNT, ResponseKeyLM, 
</span></span><span class=line><span class=cl> CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge, Time, ServerName)
</span></span><span class=line><span class=cl> As
</span></span><span class=line><span class=cl> If (User is set to &#34;&#34; AND Passwd is set to &#34;&#34;)
</span></span><span class=line><span class=cl>     -- Special case for anonymous authentication
</span></span><span class=line><span class=cl>     Set NtChallengeResponseLen to 0
</span></span><span class=line><span class=cl>     Set NtChallengeResponseMaxLen to 0
</span></span><span class=line><span class=cl>     Set NtChallengeResponseBufferOffset to 0
</span></span><span class=line><span class=cl>     Set LmChallengeResponse to Z(1)
</span></span><span class=line><span class=cl> ElseIf
</span></span><span class=line><span class=cl> If (NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY flag is set in NegFlg) 
</span></span><span class=line><span class=cl>         Set NtChallengeResponse to DESL(ResponseKeyNT, 
</span></span><span class=line><span class=cl>         MD5(ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge, 
</span></span><span class=line><span class=cl>         ClientChallenge))[0..7])
</span></span><span class=line><span class=cl>         Set LmChallengeResponse to ConcatenationOf{ClientChallenge, 
</span></span><span class=line><span class=cl>         Z(16)}
</span></span><span class=line><span class=cl>     Else 
</span></span><span class=line><span class=cl>         Set NtChallengeResponse to DESL(ResponseKeyNT, 
</span></span><span class=line><span class=cl>         CHALLENGE_MESSAGE.ServerChallenge)
</span></span><span class=line><span class=cl>         If (NoLMResponseNTLMv1 is TRUE)
</span></span><span class=line><span class=cl>             Set LmChallengeResponse to NtChallengeResponse
</span></span><span class=line><span class=cl>         Else 
</span></span><span class=line><span class=cl>             Set LmChallengeResponse to DESL(ResponseKeyLM, 
</span></span><span class=line><span class=cl>             CHALLENGE_MESSAGE.ServerChallenge)
</span></span><span class=line><span class=cl>         EndIf
</span></span><span class=line><span class=cl>     EndIf
</span></span><span class=line><span class=cl> EndIf
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> Set SessionBaseKey to MD4(NTOWF)
</span></span></code></pre></div><p>NTLMv2：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Define NTOWFv2(Passwd, User, UserDom) as HMAC_MD5( 
</span></span><span class=line><span class=cl> MD4(UNICODE(Passwd)), UNICODE(ConcatenationOf( Uppercase(User), 
</span></span><span class=line><span class=cl> UserDom ) ) )
</span></span><span class=line><span class=cl> EndDefine
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> Define LMOWFv2(Passwd, User, UserDom) as NTOWFv2(Passwd, User, 
</span></span><span class=line><span class=cl> UserDom)
</span></span><span class=line><span class=cl> EndDefine
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> Set ResponseKeyNT to NTOWFv2(Passwd, User, UserDom)
</span></span><span class=line><span class=cl> Set ResponseKeyLM to LMOWFv2(Passwd, User, UserDom)
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> Define ComputeResponse(NegFlg, ResponseKeyNT, ResponseKeyLM,
</span></span><span class=line><span class=cl> CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge, Time, ServerName)
</span></span><span class=line><span class=cl> As
</span></span><span class=line><span class=cl> If (User is set to &#34;&#34; &amp;&amp; Passwd is set to &#34;&#34;)
</span></span><span class=line><span class=cl>     -- Special case for anonymous authentication
</span></span><span class=line><span class=cl>     Set NtChallengeResponseLen to 0
</span></span><span class=line><span class=cl>     Set NtChallengeResponseMaxLen to 0
</span></span><span class=line><span class=cl>     Set NtChallengeResponseBufferOffset to 0
</span></span><span class=line><span class=cl>     Set LmChallengeResponse to Z(1)
</span></span><span class=line><span class=cl> Else
</span></span><span class=line><span class=cl>     Set temp to ConcatenationOf(Responserversion, HiResponserversion,
</span></span><span class=line><span class=cl>     Z(6), Time, ClientChallenge, Z(4), ServerName, Z(4))
</span></span><span class=line><span class=cl>     Set NTProofStr to HMAC_MD5(ResponseKeyNT, 
</span></span><span class=line><span class=cl>     ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge,temp))
</span></span><span class=line><span class=cl>     Set NtChallengeResponse to ConcatenationOf(NTProofStr, temp)
</span></span><span class=line><span class=cl>     Set LmChallengeResponse to ConcatenationOf(HMAC_MD5(ResponseKeyLM, 
</span></span><span class=line><span class=cl>     ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge, ClientChallenge)),
</span></span><span class=line><span class=cl>     ClientChallenge )
</span></span><span class=line><span class=cl> EndIf
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> Set SessionBaseKey to HMAC_MD5(ResponseKeyNT, NTProofStr)
</span></span><span class=line><span class=cl> EndDefine
</span></span></code></pre></div><p>对比一下两者的加密算法，可以发现 NTLMv1 的加密较为简单，NTLMv2 的加密中除了 challenge 外还会将大量信息通过连接起来最后才进行加密，同时使用了 HMAC_MD5 进行以保护数据的完整性。</p><p>可以发现 NTLMv1 是不存在 NTProofStr 这个数据的，因此也可以通过是否存在 NTProofStr 来判断当前认证使用的是哪个版本，下面是 SMB2 中使用 NTLMv2 进行认证的 AUTHENTICATE 消息：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h08mt76v5yj21c00u0don.jpg loading=lazy alt=image-20220313223822719></p><p><strong>这里的 NTLMv2 Response 中的每一个字段都是受到 NTProofStr 保护的，因为 NTProofStr 是根据这些字段值和 challenge 生成出来的，因此新增或是修改其中任何一个字段都会导致服务端最后校验 NTProofStr 不成功，因为攻击者无法在没有 Hash 的情况 下重新生成 NTProofStr，这点很重要，也算是 NTLMv2 的一种保护机制。</strong></p><p>当服务端收到客户端的 Response 后，可根据服务端环境分为两种不同的处理方式：</p><ul><li>在域环境中，服务端将 Challenge、Response Username 等信息发送给 DC，由 DC 调用 NTOWFv2 、LMOWFv2 对存储于 DC 上的域成员哈希计算对应的 NTProofStr 和 LM-Response，如果与客户端传递过来的相同则认证通过，反之则不通过</li><li>在工作组环境中，服务端调用 NTOWFv2 、LMOWFv2 对存储于服务端机器上的用户哈希计算对应的 NTProofStr 和 LM-Response，如果与客户端传递过来的相同则认为认证通过，反之则不通过</li></ul><h1 id=ntlm-relay>NTLM Relay</h1><p>NTLM 有着许多的攻击面，包括诸如哈希传递（PTH）、哈希爆破等，但这些都是与哈希有关的，本文只记录与协议有关的一种攻击手法，即 NTLM Relay。</p><p>从 NTLM 的认证流程可以看出，服务端会对客户端的身份进行认证，然而客户端并不会对服务端的身份进行认证（即单向认证），也正是因为这种单向认证，才产生了 NTLM Relay 这种中间人攻击的手法。</p><p>正常的认证流程是向下图这样的：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0ao4lmdfsj20ui08q0tu.jpg loading=lazy alt="NTLM Challenge Response"></p><p>假设攻击者有能力作为中间人的身份存在于客户端与服务端之间（也就是能够让客户端主动向攻击者发起 NTLM 认证请求），此时攻击者只需要简单的转发数据包，即可以客户端的身份调用服务端所提供的服务：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0ao86gjlxj20ut0i5mzt.jpg loading=lazy alt="NTLM Relay"></p><p>以服务器的角度看，它已经完成了对客户端的身份验证，并且完全无法意识到此时的通信中存在着中间人，当身份认证完成后，攻击者可使用服务端下发的认证凭据以客户端的身份调用其对外提供的服务。</p><p>如果根据 Relay 的对象来区分，可以得出一个结论：工作组环境通常是 Relay 回自身以获得主机权限，域环境较之工作组环境扩充了许多玩法，此时则不仅局限于 Relay 自身，通常还可 Relay 至 DC 以实现其它操作。</p><p>现假设存在 A、B、C 三台主机，假设 A 和 C 上存在着某个用户名和密码均相同的用户（如 Administrator），攻击者获取到了 B 的权限并且通过某种方式可以让 A 主动发起 SMB 请求，那么攻击者可以在 B 上架设一个恶意的中转 SMB 服务器，此时 B 上获得 A 的 NTLM 认证请求并将其转发至 C 的 SMB 服务（无跨协议），从而获得 C 的主机权限，impacket 的 ntlmrelayx.py 已经很好的集成了 ntlm relay 的大部分玩法：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0auhu0zl3j213r0u043n.jpg loading=lazy alt=image-20220315203522715></p><p>上面是我通过 impacket 启动了一个恶意的 SMB 服务，并将认证请求转发给 192.168.2.112（C） 这台主机，成功认证后会在本地创建一个代理，后序我可通过此代理调用目标的 SMB 服务，比如通过 smbexec.py 实现命令执行：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0aukxgzg1j21v20eu79i.jpg loading=lazy alt=image-20220315203821491></p><p>看流量图也许能够更好的理解 NTLM Relay：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0atx94hylj226u06in32.jpg loading=lazy alt=image-20220315201536035></p><p>在上图中，A 主机（192.168.2.113）向 B 主机（192.168.2.109）发出的消息会被修改（修改部分 Client 信息）后转发到 C 主机（192.168.2.112），随后将 C 主机的响应修改部分信息后转发给 B 主机。</p><p>上面多次提到了跨协议，为什么 NTLM Relay 能够跨协议呢？<strong>这是因为 NTLM 是一个嵌入式协议，无论对于哪个上层应用来说它的认证方式是不变的，不会受到上层应用的影响，因此当攻击者收到一个 SMB 的 NTLM 认证后，可转发给其它机器的 LDAP 或是其它服务进行认证。</strong></p><h1 id=防御措施>防御措施</h1><p>上面介绍了 NTLM Relay 的攻击原理与攻击场景，接下来将主要分析微软对于 NTLM Relay 的多种防御措施，其中有几种防御措施相辅相成，相互关联，十分精彩！</p><h2 id=ms08-068>ms08-068</h2><p>NTLM Relay 不仅可以 Relay 到其它机器，在工作组环境下也可以 Relay 到发出请求的机器已获得其主机权限，如下图所示：</p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0cqdxzrxpj20nu0nimyw.jpg alt=Ghost_Potato_00.png style=zoom:75%><p>微软在2008年发布了 ms08-068 补丁用于缓解这种 Relay To Self 的场景，它是怎么工作的呢？根据文档描述，SMB 客户端在进行认证时需要循环调用 <a class=link href=https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-initializesecuritycontexta target=_blank rel=noopener><em>InitializeSecurityContext</em></a>直到其返回 SEC_E_OK 才表示认证成功，ms08-068 的修复方式是将调用函数过程中传递的 pszTargetName 由原先的 null 修改为服务端具体服务的SPN，即当我们想访问 <code>\\smb-server\share</code> 时，此处会被设置为 <code>cifs/smb-server</code> 。</p><p>接下来要介绍一下 challenge cache 机制，它是能够防御 Relay To Self 的核心原因，当然需要搭配 pszTargetName 进行使用，下面是被防御的场景，假设 A 是受害者的机器，B 是 攻击者的机器，攻击者通过某种方式让 A 向其发起了 SMB 请求，并希望 Relay To A：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>A --&gt; B --&gt; A-SMB （NEGOTIATE）
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>A-SMB --&gt; B --&gt; A （CHALLENGE），此处当 A 收到 challenge 后，会将 challenge 与 B 的 SPN 一同缓存
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>A --&gt; B --&gt; A-SMB （Response），当 A 的 SMB 服务收到 Response后，会判断 challenge 是否在本地存在，如果存在并且 SPN 不为本机，
</span></span><span class=line><span class=cl>则认为此次 Response 为 NTLM Relay 转发过来的，因此认证失败
</span></span></code></pre></div><h3 id=cve-2019-1384ghost-potato>CVE-2019-1384（Ghost Potato）</h3><p>CVE-2019-1384 则是用于绕过 ms08-068 的攻击手法，由于缓存至多存在300s，过了300s缓存就会自动被删除，因此只需要将 SMB 的请求一直保持，等待300s后再发送 Response 即可成功绕过 ms08-068 的防御。</p><img src=https://shenaniganslabs.io/images/Ghost_Potato/Ghost_Potato_05.png alt=Ghost_Potato_05.png style=zoom:75%><p>微软在 2019年12月11日 发布了修复此漏洞的补丁：<a class=link href=https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2019-1384 target=_blank rel=noopener>CVE-2019-1384</a> 。</p><h2 id=会话签名>会话签名</h2><p>正如之前说的一样，NTLM 只是身份认证层的实现，当身份认证完毕后，应用层协议会继续使用它们的协议规范进行服务的调用，后续服务调用的过程被称为会话层，会话签名是基于用户 Hash 生成的，因此攻击者无法伪造。</p><p>当认证完毕后，如果存在客户端与服务的协商的决定是要对后续所有会话进行签名，那么攻击者将无法利用 Relay ，因为攻击者无法修改会话时所调用服务的 Action 或是 Relay 去其它协议，下图是基于会话签名保护的服务调用流程：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bhpdot3kj20rk0j2dh4.jpg loading=lazy alt="Signature d&rsquo;un paquet de session"></p><p>下图是基于会话签名保护的 NTLM Relay 流程：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bhqfpmyrj20sp0p3dj6.jpg loading=lazy alt=ntlm_session_signing_failed></p><p>由于后续攻击者必然想调用自定义的 Action（如 smbexec），但由于攻击者没有办法生成会话签名，因此服务端对签名的校验失败，将拒绝提供服务。</p><h3 id=smb-signing>SMB Signing</h3><p>SMB 协议的会话签名是在 SMB 协议中实现的，不涉及 NTLM，是否需要进行签名实际上是客户端与服务端在 NTLM 认证前就已经协商好了的，首先客户端会向服务端发送一条 NEGOTIATE 消息以告知服务端其对签名的处理方式（注意此处的 NEGOTIATE 与 NTLM 无关，是 SMB 协议自己的 NEGOTIATE）：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bi7bmfsxj21c00u0ahj.jpg loading=lazy alt=image-20220316101539136></p><p>随后服务端会在 NEGOTIATE Response 中告知其对签名的处理方式：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bi9eimgpj21c00u0gtr.jpg loading=lazy alt=image-20220316101739166></p><p>可以发现此时客户端与服务端的处理方式都是 enable，那么它们到底是签名还是不签名呢？微软官方提供了一个矩阵用于确定 客户端、服务端、NTLM 版本为何值时需要进行签名，并且其中包含一系列额外条件，如域控制器是强制签名的之类。</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bibmcn1rj20uy0dswgg.jpg loading=lazy alt="Signing matrix"></p><p>通过上面的矩阵可以得出本次是否签名的结论，由于此次使用的是 SMBv2 协议，并且对话的双方均不是域控制器，因此后续会话将不进行签名验证。</p><p>当客户端向域控制器验证身份时是需要签名的，但当域控制器向另外一台域控制器验证身份时则是不需要签名的。</p><p>总结一下整个流程：</p><ul><li>对应的上层协议在 NEGOTIATE 消息中告知对方其对签名的处理方式</li><li>Client 在 NTLM NEGOTIATE 消息中告知 Server 其是否支持签名，Server 在 NTLM Challenge 中告知 Client 其是否支持签名</li><li>Client 认证完毕，发起后续会话，如果前面一系列的协商结果为需要签名，则 Client 会在后续流量中添加一个 Signature 字段用于签名，Server 与 Client 的处理方式一致</li></ul><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bih87eapj20pd0e4adj.jpg loading=lazy alt="Session signing"></p><h3 id=ldap-signing>LDAP Signing</h3><p>在调用 LDAP 服务时，客户端与服务端同样有着 3 个选项来协商是否需要进行签名：</p><ul><li>Disabled：不支持数据包签名</li><li>Negotiated：可以处理签名，但不要求一定要签名</li><li>Required：必须对数据包进行签名</li></ul><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bsq5t9zgj20us0bxt9w.jpg loading=lazy alt="LDAP signing matrix"></p><p>LDAP 是在 NTLM 认证时进行签名协商的，首先在 NTLM NEGOTIATE 消息中，客户端会设置 Flag 表示其能够处理签名：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bhvqwb0cj21c00u046t.jpg loading=lazy alt=image-20220316100431400></p><p>随后服务端会在 CHALLENGE 消息中设置 Flag 以告知其是否能够处理签名：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bhyp2sy4j21c00u0aie.jpg loading=lazy alt=image-20220316100721872></p><p>由于默认情况下除了域控外的所有主机最终的协商均为 Negotiated（两台服务器均能够处理签名），这也表示正常情况下认证完毕后的所有 LDAP 流量均受签名的保护。</p><p>可以发现 SMB 与 LDAP 的区别，SMB 的签名协商是发生在 SMB 协议上的，而 LDAP 的签名协商则是发生在 NTLM 认证时的，那是否意味着只要攻击者将 Negotiate Sign 设置为 False 即可绕过签名？可惜的是，NTLM 也有自己的消息完整性验证机制，即后文要介绍的 MIC。</p><h2 id=mic>MIC</h2><p>MIC（Message Integrity Code）的主要目的是为了保证数据的完整性，即从客户端发出去是什么数据就应该在服务端收到什么数据，它只包含在 NTLM 认证流程中的最后一条消息（AUTHENTICATE）中被发出，算法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HMAC_MD5(Session key, NEGOTIATE_MESSAGE + CHALLENGE_MESSAGE + AUTHENTICATE_MESSAGE)
</span></span></code></pre></div><p>由于 Session Key 是由用户的 Hash 所加密得到的，这也就意味着攻击者没有办法重新计算 MIC，而 MIC 中包含了三条消息，这也意味着攻击者没有办法修改前两条消息，因为这将导致服务端算出来的 MIC 无法正确校验。</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bteo7rtyj21c00u0n5f.jpg loading=lazy alt=image-20220316164318066></p><p>由于 MIC 是可选的，因此在转发数据包的过程中可以将 MIC 删除，但这是无效的，因为在 AUTHENTICATE 消息中还存在一个 msAvFlags，用于告知服务器是否要校验 MIC，当 msAvFlags 为 <strong>0x00000002</strong> 且服务器未收到 MIC 时，此次认证将被判定为失败：</p><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0bthj2n0zj21c00u07br.jpg loading=lazy alt=image-20220316164602560></p><p>遗憾的是，攻击者无法将此 Flag 设为 <strong>0x00000000</strong> 以绕过 MIC，这是由于 Flag 参与了计算 NTProofStr 的过程，它也是整个加密字符串中的一部分，因此如果修改了此 Flag，则最终服务端将无法正确验证 NTProofStr，同样将导致认证失败。</p><p>MIC 保护了三条消息的完整性，而 msAvFlags（<strong>0x00000002</strong>）则保证了 MIC 的存在，此时由于攻击者不知道认证用户的 NTLM-Hash，因此他什么也做不了。</p><h3 id=cve-2019-1040>CVE-2019-1040</h3><p><a class=link href=https://www.crowdstrike.com/ target=_blank rel=noopener>Preempt</a> 团队发现了一个用于绕过 MIC 校验机制的漏洞，编号为 CVE-2019-1040，也被称为 Drop the MIC，此漏洞已经被集成于 impacket 中，只需要再调用 ntlmrelayx 时添加一个 &ndash;remove-mic 参数即可使用，具体调用代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>serverConfig</span><span class=o>.</span><span class=n>remove_mic</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>authMessage</span> <span class=o>=</span> <span class=n>NTLMAuthChallengeResponse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>authMessage</span><span class=o>.</span><span class=n>fromString</span><span class=p>(</span><span class=n>authenticateMessageBlob</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;flags&#39;</span><span class=p>]</span> <span class=o>&amp;</span> <span class=n>NTLMSSP_NEGOTIATE_SIGN</span> <span class=o>==</span> <span class=n>NTLMSSP_NEGOTIATE_SIGN</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;flags&#39;</span><span class=p>]</span> <span class=o>^=</span> <span class=n>NTLMSSP_NEGOTIATE_SIGN</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;flags&#39;</span><span class=p>]</span> <span class=o>&amp;</span> <span class=n>NTLMSSP_NEGOTIATE_ALWAYS_SIGN</span> <span class=o>==</span> <span class=n>NTLMSSP_NEGOTIATE_ALWAYS_SIGN</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;flags&#39;</span><span class=p>]</span> <span class=o>^=</span> <span class=n>NTLMSSP_NEGOTIATE_ALWAYS_SIGN</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;flags&#39;</span><span class=p>]</span> <span class=o>&amp;</span> <span class=n>NTLMSSP_NEGOTIATE_KEY_EXCH</span> <span class=o>==</span> <span class=n>NTLMSSP_NEGOTIATE_KEY_EXCH</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;flags&#39;</span><span class=p>]</span> <span class=o>^=</span> <span class=n>NTLMSSP_NEGOTIATE_KEY_EXCH</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;flags&#39;</span><span class=p>]</span> <span class=o>&amp;</span> <span class=n>NTLMSSP_NEGOTIATE_VERSION</span> <span class=o>==</span> <span class=n>NTLMSSP_NEGOTIATE_VERSION</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;flags&#39;</span><span class=p>]</span> <span class=o>^=</span> <span class=n>NTLMSSP_NEGOTIATE_VERSION</span>
</span></span><span class=line><span class=cl>    <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;MIC&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;MICLen&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;Version&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>authMessage</span><span class=p>[</span><span class=s1>&#39;VersionLen&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span></code></pre></div><p>通过置空（置零）的方式删除了 NTLM_AUTHENTICATE 消息中的 MIC、MICLen、Version、VersionLen 字段，此时即可成功的绕过 服务端对于 MIC 的校验。</p><p>通过同样的方式删除（置零）了 NTLM_NEGOTIATE 消息中的 NTLMSSP_NEGOTIATE_ALWAYS_SIGN、NTLMSSP_NEGOTIATE_SIGN 和 NTLM_AUTHENTICATE 消息中的 NTLMSSP_NEGOTIATE_ALWAYS_SIGN、NTLMSSP_NEGOTIATE_SIGN、NEGOTIATE_KEY_EXCHANGE、NEGOTIATE_VERSION 字段，<strong>由于没有了 MIC，服务端不会对三条消息是否被篡改过进行验证，从而绕过 LDAP 签名实现 relay to LDAP。</strong></p><h2 id=epa>EPA</h2><p><strong>为了对抗跨协议 Relay 使 NTLM Relay 的危害降级</strong>，微软引入了被称为 EPA 的保护措施，这种保护的原理是将身份验证层与正在使用的协议绑定在一起，甚至与存在的 TLS 层绑定在一起(例如 LDAPS 或 HTTPS)，一般情况下，<strong>它将在最后一条 AUTHENTICATE 消息中放置一条信息，攻击者无法修改它，此信息指明了本次调用的服务（SMB、HTTP、LDAP）以及可能包含的证书等其它信息，EPA 通过服务绑定和 TLS 绑定两种方式防御跨协议 Relay。</strong></p><h3 id=service-binding>Service Binding</h3><p><img src=https://tva1.sinaimg.cn/large/e6c9d24ely1h0buq49fvuj21c00u048e.jpg loading=lazy alt=image-20220316172854322></p><p>如上图所示，Client 在 AUTHENTICATE 消息的 Response 中加入了 Target Name 这么一个属性，其中包含了 Client 想要调用的服务以及对应的 Client HostName，它也参与了 NTProofStr 的加密（可以理解为受到 NTProofStr 的保护），因此攻击者无法修改这个属性。</p><p>因此如果攻击者想调用的服务收到了此消息，并且它发现了自身提供的服务与 AUTHENTICATE 消息中的不同，那么就会拒绝提供服务，除此之外，Server 还将检查此次服务调用的 IP 与属性中是否一致，如果不一致同样会拒绝提供服务，<strong>幸运的是目前 EPA 并不是作为默认情况被使用，如果需要使用这种保护措施需要手动设置，参考 KB5005413。</strong></p><h3 id=tls-binding>TLS Binding</h3><p>如果客户端希望与封装在 TLS 中的协议如 HTTPS、LDAPS 建立会话，那么它将计算服务端的证书 Hash，并将此 Hash 存放在 Response 中，攻击者无法修改此属性，因此当攻击者尝试进行 relay 攻击时，<strong>服务端发现 Response 中的 Hash 与自身不符（如 HTTPS relay LDAPS），或是服务端没有使用 TLS（LDAP、SMB）却在 Response 中发现了 证书 Hash（SMB relay LDAPS、SMB relay HTTPS &mldr;），在遇到这两种情况时服务端都将拒绝提供服务。</strong></p><h3 id=epa-bypass>EPA &ldquo;Bypass&rdquo;</h3><p>网上目前流传了两篇文章用于介绍如何绕过 EPA 的，一篇是 <a class=link href=https://www.geekby.site/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/#5-epa-bypass target=_blank rel=noopener>geekby</a> 另一篇则是 <a class=link href=https://www.crowdstrike.com/blog/bypass-epa-ntlm-attacks-wia/ target=_blank rel=noopener>bypass-epa-ntlm-attacks-wia</a> ，说实话我不能理解为什么这被称为 Bypass，因为这种 Bypass 方式需要攻击者拥有用户哈希为前提的，但如果我有用户哈希了，为什么还要使用 NTLM Relay 呢？不过我倒是搜到了一个 CVE-2020-17162，关于这个漏洞网上还没有任何细节。</p><blockquote><p>It is a bypass of Extended Protection for Authentication(EPA) where Service Principle Name could allow Windows store UAP applications to elevate privileges.</p></blockquote><h2 id=总结>总结</h2><p>上面记录了能够防御 NTLM Relay 的四种方式，其中 ms08-068 阻止了攻击者 Relay To Self 的操作，而剩余三个防御均是用来防御 Relay To Other（Or Protocol）的操作，EPA 较之签名来说防御的更加全面一些，因此如果想真正做到完美防御 NTLM Relay，建议直接使用 EPA 作为防御机制，以及一处不知道是否已经实施的安全通告。</p><blockquote><p>微软于 2019-09-11 日发布相关通告称微软计划于 2020 年 1 月发布安全更新。为了提升域控制器的安全性，该安全更新将强制开启所有域控制器上 LDAP channel binding 与 LDAP signing 功能。</p></blockquote><h1 id=reference>Reference</h1><ul><li><a class=link href=https://docs.microsoft.com/zh-cn/openspecs/windows_protocols/ms-nlmp/b38c36ed-2804-4868-a9ff-8dd3182128e4 target=_blank rel=noopener>NT LAN Manager (NTLM) Authentication Protocol</a></li><li><a class=link href=https://shenaniganslabs.io/2019/11/12/Ghost-Potato.html target=_blank rel=noopener>Ghost-Potato</a></li><li><a class=link href=https://en.hackndo.com/ntlm-relay/ target=_blank rel=noopener>NTLM Relay</a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/>内网渗透</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2022/10/10/pass-the-hash-pass-the-key/><div class=article-details><h2 class=article-title>Pass the Hash && Pass the Key</h2></div></a></article><article><a href=/2022/03/24/kerberos-protocol/><div class=article-details><h2 class=article-title>Kerberos Protocol</h2></div></a></article></div></div></aside><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/blueimp-md5@2.18.0/js/md5.min.js></script>
<script>const gitalk=new Gitalk({clientID:"bd8a8f30f72a3cbc1f49",clientSecret:"db3fa8ecea5c9bb9f544b6edd045e7f84f5958fb",repo:"gitalk",owner:"tlmn-local",admin:["tlmn-local"],distractionFreeMode:!1,id:md5(location.pathname)});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk-container").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}gitalk.render("gitalk-container")})()</script><footer class=site-footer><section class=copyright>&copy;
2022 今日明月夜
<span id=busuanzi_value_site_uv>访客数量：<span id=busuanzi_value_site_uv></span></span>
<span id=busuanzi_container_site_pv>总访问量：<span id=busuanzi_value_site_pv></span></span></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.8.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title"></h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#概述>概述</a></li><li><a href=#两种模式>两种模式</a></li><li><a href=#hash>Hash</a><ol><li><a href=#lm-hash-加密算法>LM-Hash 加密算法</a></li><li><a href=#nt-hash-加密算法>NT-Hash 加密算法</a></li><li><a href=#验证>验证</a></li></ol></li><li><a href=#ntlm>NTLM</a></li><li><a href=#ntlm-relay>NTLM Relay</a></li><li><a href=#防御措施>防御措施</a><ol><li><a href=#ms08-068>ms08-068</a><ol><li><a href=#cve-2019-1384ghost-potato>CVE-2019-1384（Ghost Potato）</a></li></ol></li><li><a href=#会话签名>会话签名</a><ol><li><a href=#smb-signing>SMB Signing</a></li><li><a href=#ldap-signing>LDAP Signing</a></li></ol></li><li><a href=#mic>MIC</a><ol><li><a href=#cve-2019-1040>CVE-2019-1040</a></li></ol></li><li><a href=#epa>EPA</a><ol><li><a href=#service-binding>Service Binding</a></li><li><a href=#tls-binding>TLS Binding</a></li><li><a href=#epa-bypass>EPA &ldquo;Bypass&rdquo;</a></li></ol></li><li><a href=#总结>总结</a></li></ol></li><li><a href=#reference>Reference</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KMSQF1H3J6"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KMSQF1H3J6")</script></body></html>